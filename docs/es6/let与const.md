# let与const

### 块级作用域:只在声明所在的块级作用域内有效
   - ES5 只有全局作用域和函数作用域，没有块级作用域
   - 为什么需要块级作用域？没有块级作用域，会带来很多不合理的场景:
     - 内层变量可能会覆盖外层变量
     - 用来计数的循环变量泄露为全局变量
   - ES6 允许块级作用域的任意嵌套
     - 每一层都是一个单独的作用域, 第四层作用域无法读取第五层作用域的内部变量
     - 内层作用域可以定义外层作用域的同名变量
   - 块级作用域与函数声明 ？？？
     - 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句
   - ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域
   - 块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域。if语句和for语句属于块作用域，不属于函数作用域
   - for循环的计数器，就很合适使用let命令，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
### 不存在变量提升
   - var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined
   - let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错
### 暂时性死区(TDZ):只能在声明的位置后面使用
   - ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域,不再受外部的影响。凡是在声明之前就使用这些变量，就会报错。
   - 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
   - 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 不允许重复声明 
  - 不允许在相同作用域内，重复声明同一个变量

### const 命令
- const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值,对于const来说，只声明不赋值，就会报错

- 本质：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动
  - 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了
  - 对于复合类型的变量，如数组和对象，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心


### ES6 声明变量的六种方法
  - ES5 只有两种声明变量的方法：var命令和function命令
  - ES6 除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法

### 顶层对象的属性 ？？？
- https://www.jianshu.com/p/7d14532094d2
- 关于null和object.is()

- == 与 === 的区别？
  - == 自动转换数据类型， 而=== 认为 NaN!==NaN为true，+0 === -0 为true,
- === 与 Object.is()?
  - Object.is(NaN,NaN)为true, Object.is(+0,-0)为false
  - null == null 为true, null === null 为true, Object.is(null, null)为true