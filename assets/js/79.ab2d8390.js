(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{437:function(a,t,e){"use strict";e.r(t);var r=e(44),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"vue面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[a._v("#")]),a._v(" vue面试题")]),a._v(" "),e("h2",{attrs:{id:"_1-v-show和v-if的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-v-show和v-if的区别"}},[a._v("#")]),a._v(" 1.v-show和v-if的区别？")]),a._v(" "),e("h2",{attrs:{id:"_2-为何v-for中要用key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-为何v-for中要用key"}},[a._v("#")]),a._v(" 2.为何v-for中要用key?")]),a._v(" "),e("h2",{attrs:{id:"_3-描述vue组件生命周期-有父子组件的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-描述vue组件生命周期-有父子组件的情况"}},[a._v("#")]),a._v(" 3.描述vue组件生命周期（有父子组件的情况）？")]),a._v(" "),e("h2",{attrs:{id:"_4-vue组件如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue组件如何通信"}},[a._v("#")]),a._v(" 4.vue组件如何通信？")]),a._v(" "),e("h2",{attrs:{id:"_5-描述组件渲染和更新的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-描述组件渲染和更新的过程"}},[a._v("#")]),a._v(" 5.描述组件渲染和更新的过程？")]),a._v(" "),e("h2",{attrs:{id:"_6-双向数据绑定v-model的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-双向数据绑定v-model的原理"}},[a._v("#")]),a._v(" 6.双向数据绑定v-model的原理？")]),a._v(" "),e("h2",{attrs:{id:"vue原理考察"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue原理考察"}},[a._v("#")]),a._v(" vue原理考察")]),a._v(" "),e("h2",{attrs:{id:"组件化和mvvm-响应式原理-vdom和diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件化和mvvm-响应式原理-vdom和diff"}},[a._v("#")]),a._v(" 组件化和mvvm，响应式原理，vdom和diff")]),a._v(" "),e("h2",{attrs:{id:"模版编译-组件渲染过程-前端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模版编译-组件渲染过程-前端路由"}},[a._v("#")]),a._v(" 模版编译，组件渲染过程，前端路由")]),a._v(" "),e("h2",{attrs:{id:"如何理解vue中的diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何理解vue中的diff算法"}},[a._v("#")]),a._v(" 如何理解vue中的diff算法？")]),a._v(" "),e("ul",[e("li",[a._v("概念上，diff算法并非vue所专用，react中也有使用，凡是用到虚拟dom的都会用到diff算法")]),a._v(" "),e("li",[a._v("源码分析1，必要性，lifecycle.js - mountComponent() -由$mount调用，")])]),a._v(" "),e("h2",{attrs:{id:"react面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react面试题"}},[a._v("#")]),a._v(" react面试题")]),a._v(" "),e("h2",{attrs:{id:"_1-react组件如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-react组件如何通信"}},[a._v("#")]),a._v(" 1.react组件如何通信？")]),a._v(" "),e("h2",{attrs:{id:"_2-jsx本质是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-jsx本质是什么"}},[a._v("#")]),a._v(" 2.jsx本质是什么？")]),a._v(" "),e("h2",{attrs:{id:"_3-context是什么-有何作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-context是什么-有何作用"}},[a._v("#")]),a._v(" 3.context是什么，有何作用？")]),a._v(" "),e("h2",{attrs:{id:"_4-shouldcomponentupdate的用途"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-shouldcomponentupdate的用途"}},[a._v("#")]),a._v(" 4.shouldComponentUpdate的用途？")]),a._v(" "),e("h2",{attrs:{id:"_5-描述redux单项数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-描述redux单项数据流"}},[a._v("#")]),a._v(" 5.描述redux单项数据流？")]),a._v(" "),e("h2",{attrs:{id:"_6-setstate是同步还是异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-setstate是同步还是异步"}},[a._v("#")]),a._v(" 6.setState是同步还是异步？")]),a._v(" "),e("h2",{attrs:{id:"框架综合应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#框架综合应用"}},[a._v("#")]),a._v(" 框架综合应用")]),a._v(" "),e("h2",{attrs:{id:"_1-基于react设计一个todolist-组件结构-redux-state数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基于react设计一个todolist-组件结构-redux-state数据结构"}},[a._v("#")]),a._v(" 1.基于react设计一个todolist(组件结构， redux state数据结构)")]),a._v(" "),e("h2",{attrs:{id:"_2-基于vue设计一个购物车-组件结构-vuex-state数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于vue设计一个购物车-组件结构-vuex-state数据结构"}},[a._v("#")]),a._v(" 2.基于vue设计一个购物车（组件结构， vuex state数据结构）")]),a._v(" "),e("h2",{attrs:{id:"webpack面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack面试题"}},[a._v("#")]),a._v(" webpack面试题")]),a._v(" "),e("h2",{attrs:{id:"_1-前端代码为何要进行构建和打包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-前端代码为何要进行构建和打包"}},[a._v("#")]),a._v(" 1.前端代码为何要进行构建和打包？")]),a._v(" "),e("h2",{attrs:{id:"_2-module-chunk-bundle-分别是什么意思-有何区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-module-chunk-bundle-分别是什么意思-有何区别"}},[a._v("#")]),a._v(" 2.module chunk bundle 分别是什么意思，有何区别？")]),a._v(" "),e("h2",{attrs:{id:"_3-loader和plugin-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-loader和plugin-的区别"}},[a._v("#")]),a._v(" 3.loader和plugin 的区别？")]),a._v(" "),e("h2",{attrs:{id:"_4-webpack如何实现懒加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-webpack如何实现懒加载"}},[a._v("#")]),a._v(" 4.webpack如何实现懒加载？")]),a._v(" "),e("h2",{attrs:{id:"_5-webpack常见性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-webpack常见性能优化"}},[a._v("#")]),a._v(" 5.webpack常见性能优化？")]),a._v(" "),e("h2",{attrs:{id:"_6-babel-runtime和babel-polyfill的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-babel-runtime和babel-polyfill的区别"}},[a._v("#")]),a._v(" 6.babel-runtime和babel-polyfill的区别？")])])}),[],!1,null,null,null);t.default=s.exports}}]);