(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{380:function(t,a,e){"use strict";e.r(a);var s=e(44),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"作用域和闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域和闭包"}},[t._v("#")]),t._v(" 作用域和闭包")]),t._v(" "),e("h2",{attrs:{id:"settimeout"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#settimeout"}},[t._v("#")]),t._v(" setTimeout")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//  请你预测一下代码会输出什么？\nfor(var i = 0; i <= 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    },1000)\n}\n")])])]),e("ul",[e("li",[e("p",[t._v("如果你没有理解透js作用域和闭包的知识点的话，你可能会认为这道题的输出顺序是：\nfor循环，输出1，2，3，4，5.  或者循环输出1~5")])]),t._v(" "),e("li",[e("p",[t._v("但是实际的答案在log之后循环输出了五个数字6！！")])]),t._v(" "),e("li",[e("p",[t._v("接着可能面试官会让你改下代码，期望结果是每间隔一秒输出一个数字，即等待1秒  输出1，等待2秒 输出2，等到3秒 输出3....")])]),t._v(" "),e("li",[e("p",[t._v("回过来看看这段代码的执行顺序，首先for循环执行，在js引擎读到setTimeout时，因为setTimeout不是立即执行的，他们的回调会被push到宏任务队列中，再回头执行任务队列中的回调函数时，变量i早就变成了6。知道了原因，我们着手解决问题。这里我们需要给setTimeout创建一个闭包的环境，让它的回调函数顺利取到循环中的变量i就解决问题了。")])])]),t._v(" "),e("ol",[e("li",[t._v("使用IIFE（立即执行的匿名函数）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//间隔1秒依次输出1，2，3，4, 5\nfor(var i = 1; i <= 5; i++) {\n    (function(i){\n        setTimeout(function() {\n            console.log(i);\n        }, i*1000)\n    })(i);\n}\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("使用ES6语法中的let来声明变量i\n==es6中的let声明的变量是具有块级作用域的，所以我们可以大胆的使用==")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("for(let i = 1;i <=5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    },i*1000)\n}\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("使用bind方法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("for(var i = 1; i <= 5; i++) {\n     setTimeout(function(i) {\n        console.log(i);\n    }.bind(null, i)，i*1000)\n}\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("利用setTimeout的第三个参数！！注意：setTineout的第三个参数及以后的参数都可以作为回调函数的参数哦")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("for(var i = 1; i<= 5;i++) {\n    setTimeout(function time(i) {\n        console.log(i);\n    },i*1000,i)\n }\n")])])]),e("ul",[e("li",[t._v("关于setTimeout的延时参数")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("setTimeout(function() {\n  console.log('代码执行了')；\n},3000)\n")])])]),e("ul",[e("li",[t._v("我们一般说代码在3秒之后执行，这样的说法是不严谨的。")]),t._v(" "),e("li",[t._v("准确的解释是：3秒后，setTimeout里的函数被推入event queue,而event queue里的任务，只有在主线程空闲下来之后才会去执行。\n如果主线程上有很多任务执行，超过3秒，比如执行了10秒，那么这个函数只能在10秒之后才能执行")]),t._v(" "),e("li",[t._v("另外：为了确保浏览器的执行一致，HTML5规范规定设置的最小延迟是4ms")])]),t._v(" "),e("h2",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),e("ul",[e("li",[t._v("作用域是根据名称查找变量的一套规则")]),t._v(" "),e("li",[t._v("作用域查找：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止")]),t._v(" "),e("li",[t._v("JS中有全局作用域，函数作用域，块级作用域")])]),t._v(" "),e("h2",{attrs:{id:"词法作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[t._v("#")]),t._v(" 词法作用域")]),t._v(" "),e("ul",[e("li",[t._v("词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域意味着作用域是由书写代码时函数声明的位置来决定的")]),t._v(" "),e("li",[t._v("JavaScript所采用的作用域模型，就是词法作用域模型")]),t._v(" "),e("li",[t._v("无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定")]),t._v(" "),e("li",[t._v("(function foo(){ .. })作为函数表达式意味着foo只能在．．所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域")])]),t._v(" "),e("h2",{attrs:{id:"声明提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明提升"}},[t._v("#")]),t._v(" 声明提升")]),t._v(" "),e("ul",[e("li",[t._v("变量声明和函数声明会被提升到所在作用域的顶部，这个过程就叫作提升")]),t._v(" "),e("li",[t._v("块作用域中没有声明提升，声明提升只出现在全局作用域和函数作用域中")]),t._v(" "),e("li",[t._v("只有声明本身会被提升，而赋值或其他运行逻辑会留在原地")]),t._v(" "),e("li",[t._v("函数声明会被提升，但是函数表达式却不会被提升")]),t._v(" "),e("li",[t._v("顺序问题：函数声明会首先被提升，然后才是变量声明")]),t._v(" "),e("li",[t._v("覆盖问题，同名的声明，后面的会覆盖前面的")]),t._v(" "),e("li",[t._v("一个普通块内部的函数声明通常会被提升到所在作用域的顶部，通常会提升出该块")]),t._v(" "),e("li",[t._v("下面代码中foo()放在不同的位置会有不同的结果")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//foo()  2\nvar foo = '4'\n//foo()  会报错\nfunction foo(){\n  console.log('1')\n}\n//foo() 会报错\nvar foo = function(){\n  console.log('3')\n}\n//foo() 3\nfunction foo(){\n  console.log('2')\n}\n")])])]),e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("ul",[e("li",[t._v("定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行, 闭包就是该函数对原始定义作用域的引用")])]),t._v(" "),e("h2",{attrs:{id:"闭包的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用"}},[t._v("#")]),t._v(" 闭包的使用")]),t._v(" "),e("ul",[e("li",[t._v("无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，这个引用就是闭包")]),t._v(" "),e("li",[t._v("由于内部函数一直持有对原始定义作用域的引用，因此该作用域不会被垃圾回收机制回收，很容易造成内存泄漏，所以要慎用闭包")]),t._v(" "),e("li",[t._v("本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function foo(){\n  var a =2;\n  function bar(){\n    console.log(a)\n  }\n  bar()\n}\nfoo() //2\n\nvar a = 3;\n(function IIFE(){\n  console.log(a) //3\n})()\n")])])]),e("ul",[e("li",[t._v("第一段代码最准确地用来解释bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）")]),t._v(" "),e("li",[t._v("第二段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有a）。a是通过普通的词法作用域查找而非闭包被发现的")])])])}),[],!1,null,null,null);a.default=n.exports}}]);