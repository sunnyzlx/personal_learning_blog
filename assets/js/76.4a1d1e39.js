(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{434:function(e,t,a){"use strict";a.r(t);var v=a(44),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue性能优化"}},[e._v("#")]),e._v(" vue性能优化")]),e._v(" "),a("ul",[a("li",[e._v("vue本身的性能优化已经做得很好了，vue组件级的响应式以及组件内的虚拟dom，两者配合，更新的颗粒度的控制都做得很好，甚至不需要时间切片来优化项目大小，项目本身已经足够小了")]),e._v(" "),a("li",[e._v("主要的性能问题集中在工程化和项目的写法上")])]),e._v(" "),a("h2",{attrs:{id:"主要考虑以下几个方面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要考虑以下几个方面"}},[e._v("#")]),e._v(" 主要考虑以下几个方面")]),e._v(" "),a("h3",{attrs:{id:"内存泄漏-内存清理-beforecreate-定时器-自定义事件及时释放"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏-内存清理-beforecreate-定时器-自定义事件及时释放"}},[e._v("#")]),e._v(" 内存泄漏，内存清理（beforeCreate）,定时器，自定义事件及时释放")]),e._v(" "),a("h3",{attrs:{id:"避免一些无意义的响应式赋值-mounted后this-xx赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免一些无意义的响应式赋值-mounted后this-xx赋值"}},[e._v("#")]),e._v(" 避免一些无意义的响应式赋值， mounted后this.xx赋值")]),e._v(" "),a("h3",{attrs:{id:"预渲染-prerender-按需加载-异步组件-比如echarts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预渲染-prerender-按需加载-异步组件-比如echarts"}},[e._v("#")]),e._v(" 预渲染（Prerender), 按需加载，异步组件（比如echarts）")]),e._v(" "),a("h3",{attrs:{id:"横向扩展-运维-负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#横向扩展-运维-负载均衡"}},[e._v("#")]),e._v(" 横向扩展（运维，负载均衡）")]),e._v(" "),a("h3",{attrs:{id:"扁平化数据设计-data和store"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扁平化数据设计-data和store"}},[e._v("#")]),e._v(" 扁平化数据设计（data和store）")]),e._v(" "),a("h2",{attrs:{id:"组件化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[e._v("#")]),e._v(" 组件化")]),e._v(" "),a("ul",[a("li",[e._v("参考elementUI,每个类型实现一个，实现核心功能即可")])]),e._v(" "),a("h3",{attrs:{id:"虚拟列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表"}},[e._v("#")]),e._v(" 虚拟列表")]),e._v(" "),a("ul",[a("li",[e._v("没有key, 怎么重用dom")]),e._v(" "),a("li",[e._v("每个元素高度并不是写死的")]),e._v(" "),a("li",[e._v("handleScroll考虑截流防抖")]),e._v(" "),a("li",[e._v("无限滚动  滚动翻页")])]),e._v(" "),a("h3",{attrs:{id:"notice-vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notice-vue"}},[e._v("#")]),e._v(" Notice.vue")]),e._v(" "),a("ul",[a("li",[e._v("plugin.js,作用：1）将notice.vue组件挂载到原型链之上，2）把组件创建出来挂载到body之上，并且定义remove方法，在隐藏同时删除dom节点")])]),e._v(" "),a("h2",{attrs:{id:"ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssr"}},[e._v("#")]),e._v(" ssr")]),e._v(" "),a("h2",{attrs:{id:"权限"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#权限"}},[e._v("#")]),e._v(" 权限")]),e._v(" "),a("h2",{attrs:{id:"浏览器原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理"}},[e._v("#")]),e._v(" 浏览器原理")]),e._v(" "),a("h2",{attrs:{id:"网络协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络协议"}},[e._v("#")]),e._v(" 网络协议")]),e._v(" "),a("h2",{attrs:{id:"vue3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[e._v("#")]),e._v(" vue3")]),e._v(" "),a("ul",[a("li",[e._v("新的api-composition, 类似react的hooks")]),e._v(" "),a("li",[e._v("全面的ts的支持")]),e._v(" "),a("li",[e._v("Proxy取代defineProperty，性能更好，但是兼容性更差")]),e._v(" "),a("li",[e._v("vdom重构，更细致的静态标记")])]),e._v(" "),a("h2",{attrs:{id:"vue源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue源码"}},[e._v("#")]),e._v(" vue源码")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("代码看不懂时优先看test,帮助理解")])]),e._v(" "),a("li",[a("p",[e._v("v-if就是三元表达式")])]),e._v(" "),a("li",[a("p",[e._v("$mount(), new Vue({})没有配置render(),写的是template, 拿到template字符串，调用编译模块，把tempalte解析成render()函数，返回虚拟dom, 如果没有compiler模块，就不能写template,要直接写render()函数")])]),e._v(" "),a("li",[a("p",[e._v("没带compiler的$mount,作用很简单，即挂载一个组件， mountComponent()")])]),e._v(" "),a("li",[a("p",[e._v("Vue.use(plugin) 安装插件， Vue.mixin({}) 合并参数，Vue.extend()，继承，返回一个vue的子类，最常用的是use和extend")])])]),e._v(" "),a("h3",{attrs:{id:"响应式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[e._v("#")]),e._v(" 响应式")]),e._v(" "),a("ul",[a("li",[e._v("vm --\x3e "),a("strong",[e._v("ob")]),e._v("(Observer) --\x3e Dep 依赖 --\x3e subs -> watcher(干活的)")]),e._v(" "),a("li",[e._v("data --\x3e defineReactive --\x3e defineProperty --\x3e Dep")]),e._v(" "),a("li",[e._v("data == get depend ==> Dep == add ==> renderWatcher => 渲染更新\n== set notify ==>     == update==>")]),e._v(" "),a("li",[e._v("一个组件一个渲染watcher, watcher和computed是普通的watcher，普通的watcher, 难点是缓存")])]),e._v(" "),a("h3",{attrs:{id:"_2个核心模块-compile和vdom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2个核心模块-compile和vdom"}},[e._v("#")]),e._v(" 2个核心模块：compile和vdom")]),e._v(" "),a("h4",{attrs:{id:"compile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compile"}},[e._v("#")]),e._v(" compile")]),e._v(" "),a("ul",[a("li",[e._v("把template编译为render()函数，render(）函数执行生成vdom")]),e._v(" "),a("li",[e._v("template ==> render(),经过parse解析，optimize优化，codegen生成")])]),e._v(" "),a("h4",{attrs:{id:"vdom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vdom"}},[e._v("#")]),e._v(" vdom")]),e._v(" "),a("ul",[a("li",[e._v("vdom 是用js对象来完整的描述js标签，在修改之前，先用js先算一遍，达到最少操作dom")]),e._v(" "),a("li",[e._v("Reactive，是数据变了，通知更新,而vdom是数据变了，通过diff计算需要更新的元素")]),e._v(" "),a("li",[e._v("vue1.0中没有vdom, vue2.0响应式watcher只通知到组件，组件内通过vdom来更新，从而减少watcher的粒度")])]),e._v(" "),a("h3",{attrs:{id:"vue与react中的vdom的异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue与react中的vdom的异同"}},[e._v("#")]),e._v(" vue与react中的vdom的异同")]),e._v(" "),a("ul",[a("li",[e._v("相同： 他们的vdom 都是为了解决复杂项目在浏览器中更加流畅的交互")]),e._v(" "),a("li",[e._v("不同： vue中是利用vdom和reactive,将任务做得足够细，vue中在两端进行来四次预判，利用key复用dom, react中是利用fiber(切片)，核心是将树形结构变为链表结构，每次diff的时候都可以中断，利用request的callback,利用浏览器的空闲时间来做diff, 导致任务再大浏览器不会卡顿，因为利用的是浏览器的空闲时间")])]),e._v(" "),a("h3",{attrs:{id:"vue的整个流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的整个流程"}},[e._v("#")]),e._v(" vue的整个流程")]),e._v(" "),a("h4",{attrs:{id:"_1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[e._v("#")]),e._v(" 1.")]),e._v(" "),a("ul",[a("li",[e._v("initMixin(Vue), _init,")]),e._v(" "),a("li",[e._v("stateMixin(Vue), $data,$props,$set,$delete,$watch")]),e._v(" "),a("li",[e._v("eventsMixin(Vue), $on,$once,$off,$emit")]),e._v(" "),a("li",[e._v("lifecycleMixin(Vue), _update,$forceUpdate,$destory, mountComponent,updateChildComponent,callHook")]),e._v(" "),a("li",[e._v("renderMixin(Vue), installRenderHelpers,$nextTick,_render")])]),e._v(" "),a("h4",{attrs:{id:"_2-init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-init"}},[e._v("#")]),e._v(" 2._init,")]),e._v(" "),a("ul",[a("li",[e._v("initLifecycle(vm), 初始化$parent,$root,$children,$refs")]),e._v(" "),a("li",[e._v("initEvents(vm),")]),e._v(" "),a("li",[e._v("initRender(vm), 初始化$slots,$scopedSlots,$createElement,$attrs,$listeners")]),e._v(" "),a("li",[e._v("callHook(vm, 'beforeCreate'),")]),e._v(" "),a("li",[e._v("initInjections(vm),")]),e._v(" "),a("li",[e._v("initState(vm), 初始化initProps,initMethods,initData,initComputed,initWatch")]),e._v(" "),a("li",[e._v("initProvide(vm),")]),e._v(" "),a("li",[e._v("callHook(vm, 'created')")]),e._v(" "),a("li",[e._v("vm.$mount(vm.$options.el)")])]),e._v(" "),a("h4",{attrs:{id:"_3-vm-mount-vm-options-el"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-vm-mount-vm-options-el"}},[e._v("#")]),e._v(" 3.vm.$mount(vm.$options.el)")]),e._v(" "),a("ul",[a("li",[e._v("platforms/web/entry-runtime-with-compiler.js中的$mount, 看看有没有render选项，如果有,直接执行mount.call(this, el, hydrating),如果没有，解析template或el选项为render函数，再执行")]),e._v(" "),a("li",[e._v("mount.call(this, el, hydrating),是platforms/web/runtime/index中的$mount,不带编译器的compiler的$mount,作用很简单，就是挂载一个组件，执行mountComponent()")])]),e._v(" "),a("h4",{attrs:{id:"_4-mountcomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-mountcomponent"}},[e._v("#")]),e._v(" 4.mountComponent()")]),e._v(" "),a("ul",[a("li",[e._v("mountComponent在core/instance/lifecycle.js中")]),e._v(" "),a("li",[e._v("初始化$el,callHook(vm, 'beforeMount'),定义updateComponent函数,初始化new Watcher(vm, updateComponent),")])]),e._v(" "),a("h4",{attrs:{id:"_5-new-watcher-vm-updatecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-new-watcher-vm-updatecomponent"}},[e._v("#")]),e._v(" 5.new Watcher(vm, updateComponent)")]),e._v(" "),a("ul",[a("li",[e._v("this.value = this.lazy? undefined : this.get()")]),e._v(" "),a("li",[e._v("this.get()中value = this.getter.call(vm, vm),即执行更新函数\nupdateComponent()")])]),e._v(" "),a("h4",{attrs:{id:"_6-updatecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-updatecomponent"}},[e._v("#")]),e._v(" 6.updateComponent()")]),e._v(" "),a("ul",[a("li",[e._v("vm._update(vm._render(), hydrating)")]),e._v(" "),a("li",[e._v("_render()函数,将template转换为vdom")]),e._v(" "),a("li",[e._v("_update()函数，将vdom转为真实dom, parse解析，optimise优化，codegen生成")])]),e._v(" "),a("h4",{attrs:{id:"_7-整个过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-整个过程"}},[e._v("#")]),e._v(" 7.整个过程")]),e._v(" "),a("ul",[a("li",[e._v("new Vue(options) -> this._init(options) -> initLifecycle(vm),initEvents(vm),initRender(vm),callHook(vm, 'beforeCreate'),initInjections(vm),initState(vm),initProvide(vm),callHook(vm, 'created'),vm.$mount(vm.$options.el) ->")])])])}),[],!1,null,null,null);t.default=r.exports}}]);