(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{367:function(n,t,e){"use strict";e.r(t);var r=e(44),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"js原理题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js原理题"}},[n._v("#")]),n._v(" JS原理题")]),n._v(" "),e("h3",{attrs:{id:"call-apply-bind-三者的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind-三者的区别"}},[n._v("#")]),n._v(" call,apply,bind 三者的区别:")]),n._v(" "),e("ul",[e("li",[n._v("共同点就是修改this指向，不同点就是")]),n._v(" "),e("li",[n._v("1.call()和apply()是立刻执行的， 而bind()是返回了一个函数")]),n._v(" "),e("li",[n._v("2.call则可以传递多个参数，第一个参数和apply一样，是用来替换的对象，后边是参数列表。")]),n._v(" "),e("li",[n._v("3.apply最多只能有两个参数——新this对象和一个数组argArray")])]),n._v(" "),e("h3",{attrs:{id:"_1-实现一个call函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-实现一个call函数"}},[n._v("#")]),n._v(" 1. 实现一个call函数")]),n._v(" "),e("ul",[e("li",[n._v("思路：将要改变this指向的方法挂到目标this上执行并返回，核心是借助this的隐式绑定")]),n._v(" "),e("li",[n._v("https://github.com/mqyqingfeng/Blog/issues/11")]),n._v(" "),e("li",[n._v("call做了什么:\n"),e("ul",[e("li",[n._v("将函数设为对象的属性")]),n._v(" "),e("li",[n._v("执行&删除这个函数")]),n._v(" "),e("li",[n._v("指定this到函数并传入给定参数执行函数")]),n._v(" "),e("li",[n._v("如果不传入参数，默认指向为 window")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myCall = function(ctx) {\n  if (typeof this !== 'function') {\n    throw new TypeError('not function')\n  }\n  //1.判断有没有传入要绑定的对象，没有默认是window，\n  //如果是基本类型的话通过Object()方法进行转换\n  ctx = Object(ctx) || window\n  let aArgs = Array.prototype.slice.call(arguments, 1)\n  /**\n    在指向的对象obj上新建一个fn属性，值为this，也就是fn()\n    相当于obj变成了\n    {\n        value: 'foo',\n        fn: function fn() {\n          console.log(this.value);\n        }\n    }\n  */\n  ctx.fn = this\n  let result = ctx.fn(...args);\n  // 删除该属性\n  delete ctx.fn;\n  return result;\n};\n\n//下面是三种截取除第一个参数之外剩余参数的方法\n//const args = [...arguments].slice(1);\n//const args = Array.prototype.slice.call(arguments, 1);\n//const args = Array.from(arguments).slice(1);\n")])])]),e("h3",{attrs:{id:"_2-实现一个apply函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现一个apply函数"}},[n._v("#")]),n._v(" 2. 实现一个apply函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myApply = function(ctx) {\n  ctx = Object(ctx) || window;\n  ctx.fn = this;\n  let args = Array.prototype.slice(arguments, 1)\n  let result;\n  if (!args) {\n    result = ctx.fn();\n  } else {\n    result = ctx.fn(...args)\n  }\n  delete ctx.fn;\n  return result;\n};\n")])])]),e("h3",{attrs:{id:"_3、实现一个bind函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、实现一个bind函数"}},[n._v("#")]),n._v(" 3、实现一个bind函数")]),n._v(" "),e("ul",[e("li",[n._v("https://github.com/mqyqingfeng/Blog/issues/12")]),n._v(" "),e("li",[n._v("https://juejin.im/post/5e17f16f5188254d3f73c7df")]),n._v(" "),e("li",[n._v("实现bind要做什么\n"),e("ul",[e("li",[n._v("返回一个函数，绑定this，传递预置参数")]),n._v(" "),e("li",[n._v("bind返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传入的参数依然有效")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// mdn的实现\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(ctx) {\n    //判断调用bind的是不是一个函数，不是的话就要抛出错误\n    if (typeof this !== 'function') {\n      throw new Error('not function')\n    }\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(\n            (this instanceof fBound ? this : ctx), \n            aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    // 维护原型关系\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype; \n    }\n    // 下行的代码使fBound.prototype是fNOP的实例,因此\n    // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\nlet obj = {\n  a:1\n}\nfunction fn(name, age){\n  this.test = '测试数据1' \n  console.log(this.a)\n  console.log(name, age)\n  return this.test\n}\nfn.prototype.f = \"测试数据2\"\n\nlet a = fn.myBind(obj, 'xiao')\nlet b = new a('ming')\nb.f = '测试数据3'\nconsole.log(b)\nconsole.log(b.__proto__ === fn.prototype)\nconsole.log(b.__proto__.__proto__ === fn.prototype)\n")])])]),e("h3",{attrs:{id:"_4、object-create的基本实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、object-create的基本实现原理"}},[n._v("#")]),n._v(" 4、Object.create的基本实现原理")]),n._v(" "),e("ul",[e("li",[n._v("Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function create(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n\nfunction create(obj) {\n  return {\n    '__proto__': obj\n  }\n}\n\nfunction create(obj){\n  return Object.setPrototypeOf({}, obj)\n}\n")])])]),e("h3",{attrs:{id:"_5、instanceof的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、instanceof的原理"}},[n._v("#")]),n._v(" 5、instanceof的原理")]),n._v(" "),e("ul",[e("li",[n._v("思路：右边变量的原型存在于左边变量的原型链上")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function instance_of(L, R) {\n  //L 表示左表达式，R 表示右表达式\n  var O = R.prototype; // 取 R 的显示原型\n  L = L.__proto__; // 取 L 的隐式原型\n  while (true) {\n    if (L === null) return false;\n    if (O === L)\n      // 这里重点：当 O 严格等于 L 时，返回 true\n      return true;\n    L = L.__proto__;\n  }\n}\n")])])]),e("h3",{attrs:{id:"_6、模拟new"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、模拟new"}},[n._v("#")]),n._v(" 6、模拟new")]),n._v(" "),e("ul",[e("li",[n._v("https://juejin.im/post/5bde7c926fb9a049f66b8b52")]),n._v(" "),e("li",[n._v("new操作符做了这些事：\n"),e("ul",[e("li",[n._v("它创建了一个全新的对象")]),n._v(" "),e("li",[n._v("它会被执行[[Prototype]]（也就是__proto__）链接")]),n._v(" "),e("li",[n._v("它使this指向新创建的对象")]),n._v(" "),e("li",[n._v("通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上")]),n._v(" "),e("li",[n._v("如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * 模拟实现 new 操作符\n * @param  {Function} ctor [构造函数]\n * @return {Object|Function|Regex|Date|Error}      [返回结果]\n */\nfunction newOperator(ctor){\n    if(typeof ctor !== 'function'){\n      throw 'newOperator function the first param must be a function'\n    }\n    newOperator.target = ctor // ES6 new.target 是指向构造函数\n    // 1.创建一个全新的对象，\n    // 2.并且执行[[Prototype]]链接\n    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。\n    var newObj = Object.create(ctor.prototype);\n    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Array.from(arguments);\n    // 除去ctor构造函数的其余参数\n    var argsArr = [].slice.call(arguments, 1);\n    // 3.生成的新对象会绑定到函数调用的`this`。\n    // 获取到ctor函数返回结果\n    var ctorReturnResult = ctor.apply(newObj, argsArr);\n    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null\n    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;\n    var isFunction = typeof ctorReturnResult === 'function';\n    if(isObject || isFunction){\n        return ctorReturnResult;\n    }\n    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。\n    return newObj;\n}\n\n// 无注释版\nfunction newOperator(ctor){\n  if(typeof ctor !== 'function'){\n    throw new TypeError('not function')\n  }\n  newOperator.target = ctor;\n  var args = [].slice.call(arguments,1)\n  var newObj = Object.create(ctor.prototype)\n  var res = ctor.apply(newObj, args)\n  if((typeof res === 'object'&& res !== null) || typeof res === 'function'){\n    return res\n  }\n  return newObj;\n}\n\nlet child1 = newOperator(Child1, 'child', 18)\n\n")])])]),e("h3",{attrs:{id:"_7、实现类的继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、实现类的继承"}},[n._v("#")]),n._v(" 7、实现类的继承")]),n._v(" "),e("ul",[e("li",[n._v("类的继承在几年前是重点内容，有n种继承方式各有优劣，es6普及后越来越不重要，那么多种写法有点『回字有四样写法』的意思，如果还想深入理解的去看红宝书即可，我们目前只实现一种最理想的继承方式。")]),n._v(" "),e("li",[n._v("https://juejin.im/post/5c433e216fb9a049c15f841b")]),n._v(" "),e("li",[n._v("https://juejin.im/post/5c8e409ee51d4534977bc557")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n    this.parent = name\n}\nParent.prototype = {\n  constructor: Parent, //需要手动绑定constructor属性\n  say: function() {\n      console.log(`${this.parent}: 你打篮球的样子像kunkun`)\n  }\n}\n\nfunction Child(name, parent) {\n    // 将父类的构造函数绑定在子类上\n    Parent.call(this, parent)\n    this.child = name\n}\n\n/** \n 1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类\n 2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性\n 3. Object.create是创建了父类原型的副本，与父类原型完全隔离\n*/\nChild.prototype = Object.create(Parent.prototype)\n\nChild.prototype.say = function() {\n    console.log(`${this.parent}好，我是练习时长两年半的${this.child}`);\n}\n\n\nChild.prototype.constructor = Child // 注意记得把子类的构造指向子类本身\nObject.setPrototypeOf(Child, Parent) //继承父类的静态属性\n\nvar parent = new Parent('father');\nparent.say() // father: 你打篮球的样子像kunkun\n\nvar child = new Child('cxk', 'father');\nchild.say() // father好，我是练习时长两年半的cxk\n\n")])])]),e("h3",{attrs:{id:"_7、实现一个基本的promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、实现一个基本的promise"}},[n._v("#")]),n._v(" 7、实现一个基本的Promise")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 未添加异步处理等其他边界情况\n// ①自动执行函数，②三个状态，③then\nclass Promise {\n  constructor (fn(resolve, reject)) {\n    // 三个状态\n    this.state = 'pending'\n    this.value= undefined\n    this.reason = undefined\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled'\n        this.value = value\n      }\n    }\n    let reject = value => {\n      if (this.state === 'pending') {\n        this.state = 'rejected'\n        this.reason = value\n      }\n    }\n    // 自动执行函数\n    try {\n      fn(resolve, reject)\n    } catch (e) {\n      reject(e)\n    }\n  }\n  // then 方法 有两个参数onFulfilled onRejected\n  then(onFulfilled, onRejected) {\n    switch (this.state) {\n      case 'fulfilled':\n        onFulfilled(this.value);\n        break\n      case 'rejected':\n        onRejected(this.reason);\n        break\n      default:\n    }\n  }\n}\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);