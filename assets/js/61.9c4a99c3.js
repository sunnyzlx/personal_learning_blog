(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{419:function(e,t,a){"use strict";a.r(t);var r=a(44),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react高级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react高级"}},[e._v("#")]),e._v(" React高级")]),e._v(" "),a("h2",{attrs:{id:"proptypes与defaultprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proptypes与defaultprops"}},[e._v("#")]),e._v(" PropTypes与DefaultProps")]),e._v(" "),a("ul",[a("li",[e._v("每个组件都有自己的props参数，这个参数是从父组件接收的一些属性，如何对参数的类型做校验，如何定义参数的默认值，这就需要用到PropTypes和DefaultProps")])]),e._v(" "),a("h2",{attrs:{id:"react中的ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中的ref"}},[e._v("#")]),e._v(" React中的ref")]),e._v(" "),a("ul",[a("li",[e._v("React中利用ref直接获取元素对应的DOM")]),e._v(" "),a("li",[e._v("但是不推荐使用ref，React建议使用数据驱动的方式来编写代码，尽量不要直接操作DOM，除非在一些及其复杂的业务中，如操作动画")]),e._v(" "),a("li",[e._v("使用ref可能会遇到各种各样的问题，如ref与setState合用时，可能会出现DOM更新不及时，导致获取的DOM不准确，原因时setState是异步的，如果希望页面更新后，在去获取DOM，一定要记得把获取DOM的语法，放在setState的第二个参数的函数中，它是一个回调函数")])]),e._v(" "),a("h2",{attrs:{id:"props-state与render函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props-state与render函数"}},[e._v("#")]),e._v(" Props，State与render函数")]),e._v(" "),a("ul",[a("li",[e._v("react是一个由数据驱动的框架，当数据发生变化，页面就会自动跟着变化，它背后的原理是什么呢？")]),e._v(" "),a("li",[e._v("当组件的state或者props发生改变的时候，render函数就会重新执行")]),e._v(" "),a("li",[e._v("当父组件的render函数被运行时，它的子组件的render函数都将被重新运行")]),e._v(" "),a("li",[e._v("之所以子组件的render函数会被重新执行，可以从两方面理解：1）它的props本身发生了改变，2）它是父组件的一个子组件，父组件的render函数被重新执行时，子组件的render函数也会被重新执行一次")])]),e._v(" "),a("h2",{attrs:{id:"react中的虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中的虚拟dom"}},[e._v("#")]),e._v(" React中的虚拟DOM")]),e._v(" "),a("ul",[a("li",[e._v("当组件的props或者state数据发生变化的时候，组件的render函数就会重新被执行，组件就会被重新渲染，react中实现这种重新渲染，他的性能是非常高的，因为它引入了一个虚拟DOM的概念")]),e._v(" "),a("li",[e._v("如何实现虚拟DOM？\n"),a("ul",[a("li",[e._v("实现思路：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("思路1:\n1）定义一个state,先有数据\n2）再定义一份JSX模版(render函数中return返回的即为模版)\n3）将数据与模版结合，生成真实的DOM，来显示(render函数执行时，会把数据和模版相结合，\n来生成真实的DOM，然后把DOM挂载到页面上，这样就实现了页面的渲染) \n4）一旦数据发生改变\n5）那就再做一次操作，用新的数据与模版结合，生成真实的DOM，替换原始的DOM\n缺陷：\n第一次生成了一个完整真实的DOM片段\n第二次又生成了一个完整真实的DOM片段\n第二次的DOM去替换第一次的DOM，三次操作都非常耗费性能\n\n思路2:\n1）state 数据\n2）JSX 模版\n3）将数据与模版结合，生成真实的DOM，来显示\n4）state 发生改变\n5）数据 + 模版 结合，生成真实的DOM，并不直接替换原始的DOM\n6）新的DOM（DocumentFragment,文档片段，存在与内存中）和原始的DOM做比对，找差异\n7）找出input框发生了变化\n8）只用新的DOM中的input元素，替换掉老的DOM中的input元素\n缺陷：\n性能提升不明显\n\n虚拟DOM底层原理：\n1）state 数据\n2）JSX 模版\n3）数据 + 模版 生成虚拟DOM(虚拟DOM就是一个js对象，用它来描述真实DOM)\n['div', {id: 'abc'}, ['span', {}, 'hello']]\n// 用JS生成一个js对象，代价很小，但是用js生成一个DOM元素，代价极高,\n// 因为它在底层会调用一个WebApplication级别的一个api,这种级别的api性能损耗很大\n\n4）用虚拟DOM的结构，生成真实的DOM，来显示\n<div id=\"abc\"><span>hello</span></div>\n\n5）state 发生变化\n\n6）数据 + 模版 生成新的虚拟DOM(极大的提升性能)\n['div', {id: 'abc'}, ['span', {}, 'bye bye']]\n\n7)比较原始的虚拟dom和新的虚拟dom，找出区别是span中内容(极大的提升性能)\n// 比对两个JS对象，非常节约性能\n\n8）直接操作dom,改变span中的内容\n")])])]),a("ul",[a("li",[e._v("react中引入虚拟DOM，为什么提升性能？因为它减少了对真实DOM的创建以及真实DOM的对比，取而代之，创建的都是JS对象，对比的也都是JS对象，通过这种方式，react底层实现了极大的性能飞跃")]),e._v(" "),a("li",[e._v("虚拟DOM本质上就是一个JS对象，本质上它能提高性能，是因为js中去比较js对象不怎么耗费性能，去比较真实的DOM会很耗费性能")])])])]),e._v(" "),a("h2",{attrs:{id:"深入了解虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入了解虚拟dom"}},[e._v("#")]),e._v(" 深入了解虚拟DOM")]),e._v(" "),a("ul",[a("li",[e._v("react底层操作： JSX模版 -> createElement ->（虚拟DOM）JS对象  ->  真实的DOM")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("return <div><span>hello</span></div>\nreturn React.createElement('div', {}, React.createElement('span', {}, 'hello'))\n")])])]),a("ul",[a("li",[e._v("JSX语法的存在，是为了方便代码书写，更方便，更简洁")]),e._v(" "),a("li",[e._v("虚拟DOM带来的好处：\n"),a("ul",[a("li",[e._v("性能提升（DOM的比对，变为js对象的比对）")]),e._v(" "),a("li",[e._v("使得跨端应用得以实现（在网页中，可以使用虚拟DOM生成真实的DOM，进而在浏览器中渲染出真实的页面，在RN原生应用中，可以使用虚拟DOM生成原生的组件，进而展示原生的页面，所以React既可以开发网页应用，又可以开发原生应用）")])])])]),e._v(" "),a("h2",{attrs:{id:"虚拟dom中的diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom中的diff算法"}},[e._v("#")]),e._v(" 虚拟DOM中的diff算法")]),e._v(" "),a("ul",[a("li",[e._v("虚拟DOM（JS对象）比对的方式，就叫做Diff算法，（difference）,实际上，React的Diff算法，大大的提升了两个虚拟DOM之间的比对性能")]),e._v(" "),a("li",[e._v("什么时候数据会发生变化，其实都是当调用setState时，数据才会发生变化，然后虚拟DOM才重新比对")]),e._v(" "),a("li",[e._v("setState其实是异步的，它在react底层的一个性能优化实现是，将多次setState结合为一次setState，减少虚拟DOM比对的次数")]),e._v(" "),a("li",[e._v("Diff算法比对两个虚拟DOM差异时，它会逐层比对，如果一层不满足匹配要求，那下面的就不会再去比对了，直接废弃掉，用新的替换掉旧的")]),e._v(" "),a("li",[e._v("Diff算法中，有个很重要的概念，叫做同层比对，即只比对同层虚拟DOM,发现差异后，不会再继续比对，整个对原始DOM进行全部替换，好处：比对算法简单，比对速度很快，虽然可能造成DOM重新渲染的一些浪费，但大大减少了DOM比对算法上的性能损耗")]),e._v(" "),a("li",[e._v("为什么React中做列表循环时，要引入key值？在做虚拟DOM的比对循环时，当增加key值后，虚拟DOM的比对，会根据key值做关联，有关联的元素就可以直接复用，只需要把没有做关联的元素增加到DOM树上即可，这样就提高了虚拟DOM比对的性能，但是要提高性能有一个前提，就是比对前后的key值不变，key值要保持稳定，所以不能用index做key值，因为增删dom后，index就移位了，元素对应的key值就不稳定了，这就失去了key值的意义，无法做关联复用了")])])])}),[],!1,null,null,null);t.default=n.exports}}]);