(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{423:function(t,e,a){"use strict";a.r(e);var s=a(44),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("​")]),t._v(" "),a("h2",{attrs:{id:"一、react和reactdom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、react和reactdom"}},[t._v("#")]),t._v(" 一、React和ReactDom")]),t._v(" "),a("ul",[a("li",[t._v("React使用JSX来描述UI")]),t._v(" "),a("li",[t._v("babel-loader把JSX 编译成相应的 JS 对象，React.createElement再把这个JS对象构造成React需要的虚拟dom。")]),t._v(" "),a("li",[t._v("React负责逻辑控制，数据 -> VDOM")]),t._v(" "),a("li",[t._v("ReactDom渲染实际DOM，VDOM -> DOM")])]),t._v(" "),a("h2",{attrs:{id:"二、jsx语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、jsx语法"}},[t._v("#")]),t._v(" 二、JSX语法")]),t._v(" "),a("ul",[a("li",[t._v("JSX是一种JavaScript的语法扩展,可以很好地描述UI，能够有效提高开发效率")]),t._v(" "),a("li",[t._v("基本使⽤,用{}包裹表达式")]),t._v(" "),a("li",[t._v("变量")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  const name = "react study";\n  const jsx = <div>hello, {name}</div>;\n')])])]),a("ul",[a("li",[t._v("js对象，函数都是合法表达式")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const obj = {\n  fistName: "Harry",\n  lastName: "Potter"\n};\nfunction formatName(name) {\n  return name.fistName + " " + name.lastName; \n}\nconst jsx = <div>{formatName(user)}</div>;\n')])])]),a("ul",[a("li",[t._v("jsx对象，也是合法表达式")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" const greet = <div>good</div>;\n const jsx = <div>{greet}</div>;\n")])])]),a("ul",[a("li",[t._v("条件语句")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const show = true;//false;\nconst greet = <div>good</div>;\nconst jsx = (\n  <div>\n    {/* 条件语句 */}\n    {show ? greet : "登录"} \n    {show && greet}\n  </div>\n);\n')])])]),a("ul",[a("li",[t._v("数组，数组会被作为一组子元素对待，数组中存放一组jsx可用于显示列表数据")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const a = [0, 1, 2];\nconst jsx = (\n  <div>\n    {/* 数组 */} \n    <ul>\n    {/* diff时候，⾸先比较type，然后是key，所以同级同类型元素，key值必须得唯⼀ */} \n    {a.map(item => (\n      <li key={item}>{item}</li>\n    ))}\n    </ul> \n  </div>\n);\n")])])]),a("ul",[a("li",[t._v("属性的使⽤")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' \nimport logo from "./logo.svg";\nconst jsx = (\n  <div>\n    {/* 属性:静态值用双引号，动态值用花括号;class、for等要特殊处理。 */}\n    <img src={logo} style={{ width: 100 }} className="img" />\n  </div>\n);\n')])])]),a("ul",[a("li",[t._v("CSS模块化，创建index.module.css")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import style from "./index.module.css";\n<img className={style.logo} />\n\nimport style from "./index.module.scss"; \n<img className={style.logo} />\n')])])]),a("h2",{attrs:{id:"三、正确使用setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、正确使用setstate"}},[t._v("#")]),t._v(" 三、正确使用setState")]),t._v(" "),a("h3",{attrs:{id:"setstate-partialstate-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate-partialstate-callback"}},[t._v("#")]),t._v(" setState(partialState, callback)")]),t._v(" "),a("ul",[a("li",[t._v("partialState:object|function, ⽤于产⽣与当前state合并的子集。")]),t._v(" "),a("li",[t._v("callback:function, state更新之后被调用。")])]),t._v(" "),a("h3",{attrs:{id:"关于-setstate-注意三点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于-setstate-注意三点"}},[t._v("#")]),t._v(" 关于 setState() 注意三点：")]),t._v(" "),a("ul",[a("li",[t._v("1.不要直接修改 State，⽽是应该使用 setState()")]),t._v(" "),a("li",[t._v("2.State 的更新可能是异步的，总结: setState只有在合成事件和生命周期函数中是异步的，在原生事件和setTimeout中都是同步的，这里的异步其实是批量更新")]),t._v(" "),a("li",[t._v("如果要获取到最新状态值有以下方式:")]),t._v(" "),a("li",[t._v("在回调中获取状态值")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('changeValue = v => { \n  this.setState({ counter: this.state.counter + v},\n  () => { console.log("counter", this.state.counter); })\n}\n')])])]),a("ul",[a("li",[t._v("使⽤定时器:")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setTimeout(() => { \n  this.setCounter();\n}, 0);\n")])])]),a("ul",[a("li",[t._v("原生事件中修改状态")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentDidMount(){\n  document.body.addEventListener('click', this.changeValue, false)\n}\n")])])]),a("ul",[a("li",[t._v("3.State 的更新会被合并，出于性能考虑，React在同一周期内会对多个 setState 进行批处理，后调用的 setState() 将覆盖同一周期内先调用 setState 的值")]),t._v(" "),a("li",[t._v("如果想要链式更新state, 使用参数一为带有形式参数的 updater 函数, (state, props) => stateChange")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("changeValue = v => {\n  this.setState(state => ({ counter: state.counter + v }));\n};\nsetCounter = () => {\n  this.changeValue(1);\n  this.changeValue(2); \n};\n")])])]),a("h2",{attrs:{id:"四、生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、生命周期"}},[t._v("#")]),t._v(" 四、⽣命周期")]),t._v(" "),a("h3",{attrs:{id:"生命周期方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期方法"}},[t._v("#")]),t._v(" ⽣命周期方法")]),t._v(" "),a("ul",[a("li",[t._v("生命周期方法，用于在组件不同阶段执行自定义功能。在组件被创建并插入到 DOM 时，组件更新时，组件取消挂载或从 DOM 中删除时，都有可以使用的生命周期方法。")]),t._v(" "),a("li",[t._v("V17可能会废弃的三个生命周期函数用getDerivedStateFromProps替代，⽬前使用的话加上 UNSAFE_:\n"),a("ul",[a("li",[t._v("componentWillMount")]),t._v(" "),a("li",[t._v("componentWillReceiveProps")]),t._v(" "),a("li",[t._v("componentWillUpdate")])])]),t._v(" "),a("li",[t._v("引入两个新的生命周期函数:\n"),a("ul",[a("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),a("li",[t._v("getSnapshotBeforeUpdate")])])]),t._v(" "),a("li",[t._v("如果不想手动给将要废弃的生命周期添加 UNSAFE_ 前缀，可以用下面的命令")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npx react-codemod rename-unsafe-lifecycles <path>\n")])])]),a("h2",{attrs:{id:"五、组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、组件"}},[t._v("#")]),t._v(" 五、组件")]),t._v(" "),a("ul",[a("li",[t._v("组件，从概念上类似于 JavaScript 函数。它接受任意的入参(即 “props”)，并返回用于描述页面展示内容的 React元素。")]),t._v(" "),a("li",[t._v("组件有两种形式:class组件和function组件。")])]),t._v(" "),a("h3",{attrs:{id:"class组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class组件"}},[t._v("#")]),t._v(" class组件")]),t._v(" "),a("ul",[a("li",[t._v("class组件通常拥有状态和生命周期，继承于Component，实现render方法")])]),t._v(" "),a("h3",{attrs:{id:"function组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function组件"}},[t._v("#")]),t._v(" function组件")]),t._v(" "),a("ul",[a("li",[t._v("函数组件通常无状态，仅关注内容展示，返回渲染结果即可。")]),t._v(" "),a("li",[t._v("从React16.8开始引⼊了hooks，函数组件也能够拥有状态。")])]),t._v(" "),a("h2",{attrs:{id:"六、组件复合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、组件复合"}},[t._v("#")]),t._v(" 六、组件复合")]),t._v(" "),a("ul",[a("li",[t._v("如果组件间有共用的非UI逻辑，将它们抽取为JS模块导入使用⽽不是继承它。")]),t._v(" "),a("li",[t._v("Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。")]),t._v(" "),a("li",[t._v("我们推荐使用组合而非继承来实现组件间的代码重用。典型用例Layout组件，Card组件")])]),t._v(" "),a("h3",{attrs:{id:"不具名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不具名"}},[t._v("#")]),t._v(" 不具名")]),t._v(" "),a("ul",[a("li",[t._v("使用一个特殊的props.children来将他们的子组件传递到渲染结果中")])]),t._v(" "),a("h3",{attrs:{id:"具名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具名"}},[t._v("#")]),t._v(" 具名")]),t._v(" "),a("ul",[a("li",[t._v("传个对象进去:")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import React, { Component } from "react"; \nimport Layout from "./Layout";\nexport default class HomePage extends Component {\n  render() {\n    return (\n       <Layout showTopBar={false} showBottomBar={true} title="商城⾸首⻚页"> \n        {/* <div>\n          <h3>HomePage</h3>\n        </div> */}\n        {{\n          content: (\n            <div>\n              <h3>HomePage</h3>\n            </div>),\n          txt: "这是个文本",\n          btnClick: () => {\n            console.log("btnClick"); }\n        }}\n      </Layout>); \n  }\n}\n')])])]),a("h2",{attrs:{id:"七、redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、redux"}},[t._v("#")]),t._v(" 七、redux")]),t._v(" "),a("ul",[a("li",[t._v("redux 是 JavaScript应用的状态容器，提供可预测化的状态管理。它保证程序行为⼀致性且易于测试。")])]),t._v(" "),a("h3",{attrs:{id:"redux使用步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux使用步骤"}},[t._v("#")]),t._v(" redux使用步骤")]),t._v(" "),a("ul",[a("li",[t._v("需要一个store来存储数据")]),t._v(" "),a("li",[t._v("store里的reducer初始化state并定义state修改规则")]),t._v(" "),a("li",[t._v("通过dispatch一个action来提交对数据的修改")]),t._v(" "),a("li",[t._v("action提交到reducer函数里，根据传⼊的action的type，返回新的state")])]),t._v(" "),a("h3",{attrs:{id:"react各api作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react各api作用"}},[t._v("#")]),t._v(" react各api作用")]),t._v(" "),a("ul",[a("li",[t._v("createStore 创建store")]),t._v(" "),a("li",[t._v("reducer 初始化、修改状态函数")]),t._v(" "),a("li",[t._v("getState 获取状态值")]),t._v(" "),a("li",[t._v("dispatch 提交更新")]),t._v(" "),a("li",[t._v("subscribe 变更订阅")])]),t._v(" "),a("h2",{attrs:{id:"八、react-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、react-redux"}},[t._v("#")]),t._v(" 八、react-redux")]),t._v(" "),a("ul",[a("li",[t._v("react-redux提供了两个api")]),t._v(" "),a("li",[t._v("Provider 为后代组件提供store")]),t._v(" "),a("li",[t._v("connect 为组件提供数据和变更方法，connect中的参数:state映射和事件映射")])]),t._v(" "),a("h2",{attrs:{id:"九、react-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、react-router"}},[t._v("#")]),t._v(" 九、react-router")]),t._v(" "),a("ul",[a("li",[t._v("react-router包含3个库，react-router、react-router-dom和react-router-native。react-router提供最 基本的路路由功能，实际使⽤用的时候我们不不会直接安装react-router，⽽而是根据应⽤用运⾏行行的环境选择安装 react-router-dom(在浏览器器中使⽤用)或react-router-native(在rn中使⽤用)。react-router-dom和 react-router-native都依赖react-router，所以在安装时，react-router也会⾃自动安装")]),t._v(" "),a("li",[t._v("react-router中奉⾏一切皆组件的思想，路由器-Router、链接-Link、路由-Route、独占-Switch、重定向-Redirect都以组件形式存在")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import React, { Component } from "react";\nimport { BrowserRouter as Router, Route, Link } from "react-router-dom";\nexport default class RouterPage extends Component {\n  render() {\n    return (\n      <div>\n        <h3>RouterPage</h3>\n        <Router>\n          <Link to="/">⾸首⻚页</Link>\n          <Link to="/user">⽤用户中⼼心</Link>\n          {/* 根路由要添加exact，实现精确匹配 */} \n          <Route exact  path="/"\n            component={HomePage}\n            //children={() => <div>children</div>}\n            //render={() => <div>render</div>}\n          />\n          <Route path="/user" component={UserPage} />\n        </Router>\n      </div>); \n    }\n}\n')])])]),a("h3",{attrs:{id:"route渲染内容的三种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route渲染内容的三种方式"}},[t._v("#")]),t._v(" Route渲染内容的三种方式")]),t._v(" "),a("ul",[a("li",[t._v("Route渲染优先级:children>component>render。这三种方式互斥，你只能⽤一种.")])]),t._v(" "),a("h4",{attrs:{id:"children-func"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#children-func"}},[t._v("#")]),t._v(" children:func")]),t._v(" "),a("ul",[a("li",[t._v("不管location是否匹配都会被渲染之外，其它工作方法与render完全一样")])]),t._v(" "),a("h4",{attrs:{id:"render-func"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-func"}},[t._v("#")]),t._v(" render:func")]),t._v(" "),a("ul",[a("li",[t._v("当location匹配的时候渲染,接收一个函数")])]),t._v(" "),a("h4",{attrs:{id:"component-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component-component"}},[t._v("#")]),t._v(" component: component")]),t._v(" "),a("ul",[a("li",[t._v("只在当location匹配的时候渲染。")])]),t._v(" "),a("h3",{attrs:{id:"_404⻚面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_404⻚面"}},[t._v("#")]),t._v(" 404⻚⾯")]),t._v(" "),a("ul",[a("li",[t._v("设定⼀个没有path的路由在路由列表最后面，表示一定匹配")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('{/* 添加Switch表示仅匹配一个*/} \n<Switch>\n  {/* 根路由要添加exact，实现精确匹配 */} \n  <Route\n    exact\n    path="/"\n    component={HomePage}\n  />\n  <Route path="/user" component={UserPage} />\n  <Route component={EmptyPage} />\n</Switch>\n')])])]),a("h2",{attrs:{id:"十、purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、purecomponent"}},[t._v("#")]),t._v(" 十、PureComponent")]),t._v(" "),a("ul",[a("li",[t._v("定制了shouldComponentUpdate后的Component，实现性能优化")]),t._v(" "),a("li",[t._v("缺点是必须要用class形式，⽽且要注意是浅比较")]),t._v(" "),a("li",[t._v("React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中 包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent ，或者在深层数据结构发生变化时 调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);