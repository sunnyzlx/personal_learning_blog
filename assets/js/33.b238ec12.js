(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{389:function(a,t,s){"use strict";s.r(t);var e=s(44),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"正则表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[a._v("#")]),a._v(" 正则表达式")]),a._v(" "),s("ul",[s("li",[a._v("参考：https://mp.weixin.qq.com/s/0CV6jIufuiwMwmPgRv0Zzw")]),a._v(" "),s("li",[a._v("https://wangdoc.com/javascript/stdlib/regexp.html")])]),a._v(" "),s("h2",{attrs:{id:"常用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用"}},[a._v("#")]),a._v(" 常用")]),a._v(" "),s("ul",[s("li",[a._v("\\b 单词边界， . 任意字符， * 任意个字符，+ 至少一个字符， () 分组$1 $2 $3")]),a._v(" "),s("li",[a._v("\\d 数字， {3} 量词， []表示或者，^ 开头， $ 结尾")])]),a._v(" "),s("h2",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])]),a._v(" "),s("ul",[s("li",[a._v("正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。")]),a._v(" "),s("li",[a._v("javaScript通过内置对象RegExp支持正则表达式")])]),a._v(" "),s("h2",{attrs:{id:"实例化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例化"}},[a._v("#")]),a._v(" 实例化")]),a._v(" "),s("ul",[s("li",[a._v("两种方法实例化RegExp对象，等价，都新建了一个内容为bis的正则表达式对象\n"),s("ul",[s("li",[a._v("字面量，以斜杠表示开始和结束，var reg=/\\bis\\b/g;")]),a._v(" "),s("li",[a._v("构造函数 var reg = new RegExp('\\bis\\b', g)")])])])]),a._v(" "),s("h2",{attrs:{id:"实例属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[a._v("#")]),a._v(" 实例属性")]),a._v(" "),s("ul",[s("li",[a._v("RegExp.prototype.ignoreCase,是否设置了i修饰符，默认false")]),a._v(" "),s("li",[a._v("RegExp.prototype.global,是否设置了g修饰符，默认false")]),a._v(" "),s("li",[a._v("RegExp.prototype.multiline,是否设置了m修饰符，默认false")]),a._v(" "),s("li",[a._v("RegExp.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符")]),a._v(" "),s("li",[a._v("RegExp.prototype.lastIndex,返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义（非全局搜索时不生效）")]),a._v(" "),s("li",[a._v("RegExp.prototype.source, 返回正则表达式的字符串形式（不包括反斜杠）")]),a._v(" "),s("li",[a._v("以上属性均为只读，不可修改")])]),a._v(" "),s("h2",{attrs:{id:"实例方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[a._v("#")]),a._v(" 实例方法")]),a._v(" "),s("h3",{attrs:{id:"regexp-prototype-test-str"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-test-str"}},[a._v("#")]),a._v(" RegExp.prototype.test(str)")]),a._v(" "),s("ul",[s("li",[a._v("表示当前模式是否能匹配参数字符串，匹配返回true，否则返回false")])]),a._v(" "),s("h3",{attrs:{id:"regexp-prototype-exec-str"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-exec-str"}},[a._v("#")]),a._v(" RegExp.prototype.exec(str)")]),a._v(" "),s("ul",[s("li",[a._v("用来返回匹配结果")]),a._v(" "),s("li",[a._v("若没有匹配的文本返回null,若有返回结果数组：")]),a._v(" "),s("li",[a._v("调用非全局搜索时执行exec()时，结果数组如下：\n"),s("ul",[s("li",[a._v("第一个元素是与正则表达式相匹配的文本")]),a._v(" "),s("li",[a._v("第二个元素是匹配文本中的第一个分组")]),a._v(" "),s("li",[a._v("第三，第四以此类推")]),a._v(" "),s("li",[a._v("index 模式匹配成功的开始位置（从0开始计数）")]),a._v(" "),s("li",[a._v("input 存放被检索的字符串string")])])])]),a._v(" "),s("h2",{attrs:{id:"字符串对象与正则相关的4个方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串对象与正则相关的4个方法"}},[a._v("#")]),a._v(" 字符串对象与正则相关的4个方法")]),a._v(" "),s("h3",{attrs:{id:"string-prototype-match"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-match"}},[a._v("#")]),a._v(" String.prototype.match()")]),a._v(" "),s("ul",[s("li",[a._v("字符串的match方法与正则对象的exec方法非常类似,")]),a._v(" "),s("li",[a._v("匹配成功返回一个数组，匹配失败返回null")]),a._v(" "),s("li",[a._v("但正则表达式带有g修饰符时，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果")]),a._v(" "),s("li",[a._v("且设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始")])]),a._v(" "),s("h3",{attrs:{id:"string-prototype-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-search"}},[a._v("#")]),a._v(" String.prototype.search()")]),a._v(" "),s("ul",[s("li",[a._v("返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。不执行全局匹配，总是从字符串的开始进行检索")])]),a._v(" "),s("h3",{attrs:{id:"string-prototype-replace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-replace"}},[a._v("#")]),a._v(" String.prototype.replace()")]),a._v(" "),s("ul",[s("li",[a._v("替换匹配的值，它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。")]),a._v(" "),s("li",[a._v("正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("//消除字符串首尾两端的空格\nvar str = '  #id div.class  ';\nstr.replace(/^\\s+|\\s+$/g, '') //// \"#id div.class\"\n")])])]),s("ul",[s("li",[a._v("replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。\n"),s("ul",[s("li",[a._v("$&：匹配的子字符串。")]),a._v(" "),s("li",[a._v("$`：匹配结果前面的文本。")]),a._v(" "),s("li",[a._v("$'：匹配结果后面的文本。")]),a._v(" "),s("li",[a._v("$n：匹配成功的第n组内容，n是从1开始的自然数。")]),a._v(" "),s("li",[a._v("$$：指代美元符号$。")])])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("'hello world'.replace(/(\\w+)\\s(\\w+)/, '$2 $1')\n// \"world hello\"\n\n'abc'.replace('b', '[$`-$&-$\\']')\n// \"a[a-b-c]c\"\n")])])]),s("ul",[s("li",[a._v("作为replace方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var prices = {\n  'p1': '$1.99',\n  'p2': '$9.99',\n  'p3': '$5.00'\n};\n\nvar template = '<span id=\"p1\"></span>'\n  + '<span id=\"p2\"></span>'\n  + '<span id=\"p3\"></span>';\n\ntemplate.replace(\n  /(<span id=\")(.*?)(\">)(<\\/span>)/g,\n  function(match, $1, $2, $3, $4){\n    return $1 + $2 + $3 + prices[$2] + $4;\n  }\n);\n// \"<span id=\"p1\">$1.99</span><span id=\"p2\">$9.99</span><span id=\"p3\">$5.00</span>\"\n")])])]),s("h3",{attrs:{id:"string-prototype-split"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-split"}},[a._v("#")]),a._v(" String.prototype.split()")]),a._v(" "),s("h2",{attrs:{id:"修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[a._v("#")]),a._v(" 修饰符")]),a._v(" "),s("ul",[s("li",[a._v("g，global全文搜索，若不添加，搜索到第一个匹配停止")]),a._v(" "),s("li",[a._v("i，ignore case，忽略大小写，默认大小写敏感")]),a._v(" "),s("li",[a._v("m, 多行搜索")])]),a._v(" "),s("h2",{attrs:{id:"元字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#元字符"}},[a._v("#")]),a._v(" 元字符")]),a._v(" "),s("ul",[s("li",[a._v("正则表达式由两种基本字符类型组成\n"),s("ul",[s("li",[a._v("字面量字符")]),a._v(" "),s("li",[a._v("元字符")])])]),a._v(" "),s("li",[a._v("元字符是正则表达式中由特殊含义的非字母字符")]),a._v(" "),s("li",[a._v("*, +,?, $, ^, ., |, , (), [], {}")]),a._v(" "),s("li",[a._v("一般情况下，正则表达式一个字符对应字符串一个字符")])]),a._v(" "),s("h2",{attrs:{id:"点字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#点字符"}},[a._v("#")]),a._v(" 点字符（.)")]),a._v(" "),s("ul",[s("li",[a._v("点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符,但一个点只匹配一个字符")])]),a._v(" "),s("h2",{attrs:{id:"边界字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#边界字符"}},[a._v("#")]),a._v(" 边界字符")]),a._v(" "),s("ul",[s("li",[a._v("^开始，$结束，\\b单词边界， \\B非单词边界")])]),a._v(" "),s("h2",{attrs:{id:"选择符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择符"}},[a._v("#")]),a._v(" 选择符（|）")]),a._v(" "),s("ul",[s("li",[a._v("竖线符号（|）在正则表达式中表示“或关系”")]),a._v(" "),s("li",[a._v("选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/a( |\\t)b/.test('a\\tb') // true\n//a和b之间有一个空格或者一个制表符\n")])])]),s("h2",{attrs:{id:"转义符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#转义符"}},[a._v("#")]),a._v(" 转义符")]),a._v(" "),s("ul",[s("li",[a._v("正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。")]),a._v(" "),s("li",[a._v("需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("(new RegExp('1\\+1')).test('1+1')\n// false\n\n(new RegExp('1\\\\+1')).test('1+1')\n// true\n")])])]),s("h2",{attrs:{id:"字符类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符类"}},[a._v("#")]),a._v(" 字符类")]),a._v(" "),s("ul",[s("li",[a._v("字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内[]")])]),a._v(" "),s("h3",{attrs:{id:"脱字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脱字符"}},[a._v("#")]),a._v(" 脱字符（^）")]),a._v(" "),s("ul",[s("li",[a._v("如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配")]),a._v(" "),s("li",[a._v("如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的")]),a._v(" "),s("li",[a._v("注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义")])]),a._v(" "),s("h3",{attrs:{id:"连字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#连字符"}},[a._v("#")]),a._v(" 连字符（-）")]),a._v(" "),s("ul",[s("li",[a._v("某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。- [abc]可以写成[a-c]，")]),a._v(" "),s("li",[a._v("[0123456789]可以写成[0-9]，")]),a._v(" "),s("li",[a._v("同理[A-Z]表示26个大写字母")]),a._v(" "),s("li",[a._v("当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列")]),a._v(" "),s("li",[a._v("字符类[1-31]，不代表1到31，只代表1到3")])]),a._v(" "),s("h2",{attrs:{id:"预定义类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#预定义类"}},[a._v("#")]),a._v(" 预定义类")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("正则表达式提供预定义类匹配常见的字符类")])]),a._v(" "),s("li",[s("p",[a._v(". 任意字符，除回车和换行之外的所有的字符，[^\\r\\n]")])]),a._v(" "),s("li",[s("p",[a._v("\\d 数字字符，[0-9]")])]),a._v(" "),s("li",[s("p",[a._v("\\D 非数字字符，[^0-9]")])]),a._v(" "),s("li",[s("p",[a._v("\\s 空白字符， \\S 非空白字符")])]),a._v(" "),s("li",[s("p",[a._v("\\w 匹配任意的字母、数字和下划线，[a-zA-Z0-9_]")])]),a._v(" "),s("li",[s("p",[a._v("\\W 除所有字母、数字和下划线以外的字符， [^a-zA-Z_0-9]")])]),a._v(" "),s("li",[s("p",[a._v("正则表达式遇到换行符（\\n）就会停止匹配")])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var html = "<b>Hello</b>\\n<i>world!</i>";\n\n/.*/.exec(html)[0]\n// "<b>Hello</b>"\n\n/[\\S\\s]*/.exec(html)[0]\n// "<b>Hello</b>\\n<i>world!</i>"\n\n//点字符（.）不匹配换行符,而[\\S\\s]指代一切字符\n')])])]),s("h2",{attrs:{id:"量词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#量词"}},[a._v("#")]),a._v(" 量词")]),a._v(" "),s("ul",[s("li",[a._v("？出现0次或1次, {0,1}")]),a._v(" "),s("li",[a._v("+ 出现1次或多次（至少一次）{1,}")]),a._v(" "),s("li",[a._v("* 出现0次或多次（任意次）{0,}")]),a._v(" "),s("li",[a._v("{n} 恰好重复n次")]),a._v(" "),s("li",[a._v("{n,m} 出现n到m次")]),a._v(" "),s("li",[a._v("{n,} 至少出现n次")]),a._v(" "),s("li",[a._v("量词默认匹配紧挨着的字符，若要匹配一个单词，可使用分组")])]),a._v(" "),s("h2",{attrs:{id:"贪婪模式与非贪婪模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪婪模式与非贪婪模式"}},[a._v("#")]),a._v(" 贪婪模式与非贪婪模式")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("正则表达式默认会尽可能多的匹配，即贪婪模式")])]),a._v(" "),s("li",[s("p",[a._v("而非贪婪模式则是尽可能少的匹配，即一旦匹配成功便不再尝试")])]),a._v(" "),s("li",[s("p",[a._v("在量词后加？即开启非贪婪模式")])]),a._v(" "),s("li",[s("p",[a._v("‘123456789’.match(/\\d{3,6}?/g) => ['123','456','789']")])]),a._v(" "),s("li",[s("p",[a._v("非贪婪模式的加号（+?）,匹配一个就停止")])]),a._v(" "),s("li",[s("p",[a._v("非贪婪模式的星号（*?）,匹配0个就停止")])]),a._v(" "),s("li",[s("p",[a._v("非贪婪模式的问号（??）,匹配0个就停止")])])]),a._v(" "),s("h2",{attrs:{id:"分组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[a._v("#")]),a._v(" 分组")]),a._v(" "),s("ul",[s("li",[a._v("使用括号表示分组匹配，使量词作用于分组，而非紧挨着的字符")]),a._v(" "),s("li",[a._v("正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var str = \'abcabc\';\nvar reg = /(.)b(.)/g;\nwhile (true) {\n  var result = reg.exec(str);\n  if (!result) break;\n  console.log(result);\n}\n// ["abc", "a", "c"]\n// ["abc", "a", "c"]\n')])])]),s("ul",[s("li",[a._v("正则表达式内部，还可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("/(.)b(.)\\1b\\2/.test('abcabc') //true\n/y(..)(.)\\2\\1/.test('yabccab') //true\n/y((..)\\2)/1/.test('yabababab')\n")])])]),s("ul",[s("li",[a._v("括号还可以嵌套，\\1指向外层括号，\\2指向内层括号")])]),a._v(" "),s("h2",{attrs:{id:"反向引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#反向引用"}},[a._v("#")]),a._v(" 反向引用")]),a._v(" "),s("ul",[s("li",[a._v("用$1到$n，来代表我们捕获的分组，也叫分组捕获")])]),a._v(" "),s("h2",{attrs:{id:"忽略分组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#忽略分组"}},[a._v("#")]),a._v(" 忽略分组")]),a._v(" "),s("ul",[s("li",[a._v("如果不希望捕获某些分组，只要在分组内加上？：即可")]),a._v(" "),s("li",[a._v("(?:byron).(ok)这样分组byron就被忽略了")])]),a._v(" "),s("h2",{attrs:{id:"前瞻"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前瞻"}},[a._v("#")]),a._v(" 前瞻")]),a._v(" "),s("ul",[s("li",[a._v("正则表达式从文本头部向文本尾部开始解析，文本尾部方向，称为“前”")]),a._v(" "),s("li",[a._v("前瞻就是正则表达式在匹配到规则的时候，向前检查是否符合断言")]),a._v(" "),s("li",[a._v("后顾/后瞻，方向相反，js不支持后瞻")]),a._v(" "),s("li",[a._v("符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配")]),a._v(" "),s("li",[a._v("正向前瞻， exp(?=assert)")]),a._v(" "),s("li",[a._v("负向前瞻， exp(?!assert)")]),a._v(" "),s("li",[a._v("正向后顾， exp(?<=assert) js不支持后顾")]),a._v(" "),s("li",[a._v("负向后顾， exp(?<!assert) js不支持后顾")]),a._v(" "),s("li",[a._v("‘a2"),s("em",[a._v("3’.replace(/\\w(?=\\d)/g, 'X') => 'X2")]),a._v("3' 前面是匹配部分，后面是断言部分，替换的只有匹配部分")])])])}),[],!1,null,null,null);t.default=v.exports}}]);