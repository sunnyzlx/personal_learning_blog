(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{424:function(a,t,e){"use strict";e.r(t);var r=e(44),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"react源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react源码"}},[a._v("#")]),a._v(" react源码")]),a._v(" "),e("h2",{attrs:{id:"react是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react是什么"}},[a._v("#")]),a._v(" React是什么？")]),a._v(" "),e("ul",[e("li",[a._v("React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。")]),a._v(" "),e("li",[a._v("React是使用虚拟dom来描述真实的dom节点，由于有大量的dom节点，所以又拆分成组件，所以就是使用组件构建虚拟 DOM")])]),a._v(" "),e("h2",{attrs:{id:"virtual-dom是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom是什么"}},[a._v("#")]),a._v(" Virtual DOM是什么？")]),a._v(" "),e("ul",[e("li",[a._v("Virtual DOM本质就是js对象，来描述真实的DOM结构和信息")])]),a._v(" "),e("h3",{attrs:{id:"why"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[a._v("#")]),a._v(" why")]),a._v(" "),e("ul",[e("li",[a._v("DOM操作很慢，轻微的操作都可能导致⻚面重新排版，⾮常耗性能。相对于DOM对象，js对象处理起来更快，⽽且更简单。通过diff算法对比新旧vdom之间的差异，可以批量的、最小化的执⾏dom操作，从⽽提⾼性能。")])]),a._v(" "),e("h3",{attrs:{id:"where"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#where"}},[a._v("#")]),a._v(" where")]),a._v(" "),e("ul",[e("li",[a._v("React中⽤JSX语法描述视图，通过babel-loader转译后它们变为React.createElement(...)形式，该函数将生成vdom来描述真实dom。将来如果状态变化，vdom将作出相应变化，再通过diff算法对⽐新⽼vdom区别从⽽做出最终dom操作")])]),a._v(" "),e("h2",{attrs:{id:"jsx是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jsx是什么"}},[a._v("#")]),a._v(" JSX是什么？")]),a._v(" "),e("ul",[e("li",[a._v("语法糖")]),a._v(" "),e("li",[a._v("React 使用 JSX 来替代常规的 JavaScript。")]),a._v(" "),e("li",[a._v("JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。")])]),a._v(" "),e("h3",{attrs:{id:"为什么需要jsx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要jsx"}},[a._v("#")]),a._v(" 为什么需要JSX？")]),a._v(" "),e("ul",[e("li",[a._v("开发效率:使⽤JSX编写模板简单快速。")]),a._v(" "),e("li",[a._v("执行效率:JSX编译为JavaScript代码后进⾏了优化，执⾏更快。")]),a._v(" "),e("li",[a._v("类型安全:在编译过程中就能发现错误。")])]),a._v(" "),e("h3",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理？")]),a._v(" "),e("ul",[e("li",[a._v("babel-loader会预编译JSX为React.createElement(...)")])]),a._v(" "),e("h3",{attrs:{id:"与vue的异同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与vue的异同"}},[a._v("#")]),a._v(" 与vue的异同？")]),a._v(" "),e("ul",[e("li",[a._v("react中虚拟dom+jsx的设计一开始就有，vue则是演进过程中才出现的")]),a._v(" "),e("li",[a._v("jsx本来就是js扩展，转义过程简单直接的多;vue把template编译为render函数的过程需要复杂的编译器转换：字符串-ast-js函数字符串")])]),a._v(" "),e("h2",{attrs:{id:"react核心api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react核心api"}},[a._v("#")]),a._v(" React核⼼api？")]),a._v(" "),e("ul",[e("li",[a._v("React.createElement:将传⼊的节点定义转换为vdom\n"),e("ul",[e("li",[a._v("createElement被调用时会传入标签类型type，标签属性props及若⼲子元素children")]),a._v(" "),e("li",[a._v("index.js中从未使用React类或者其任何接口，为何需要导入它?")]),a._v(" "),e("li",[a._v("JSX编译后实际调用React.createElement方法，所以只要出现JSX的文件中都需要导入React")])])]),a._v(" "),e("li",[a._v("React.Component:实现自定义组件")]),a._v(" "),e("li",[a._v("ReactDOM.render:渲染真实DOM")]),a._v(" "),e("li",[a._v("总结:")]),a._v(" "),e("li",[e("ol",[e("li",[a._v("webpack+babel编译时，替换JSX为React.createElement(type,props,...children)")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("所有React.createElement()执⾏结束后得到一个JS对象即vdom，它能够完整描述dom结构")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("ReactDOM.render(vdom, container)可以将vdom转换为dom并追加到container中")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[a._v("实际上，转换过程需要经过一个diff过程。")])])])]),a._v(" "),e("h2",{attrs:{id:"reconciliation协调-即diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation协调-即diff算法"}},[a._v("#")]),a._v(" reconciliation协调，即diff算法")]),a._v(" "),e("h3",{attrs:{id:"出现原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#出现原因"}},[a._v("#")]),a._v(" 出现原因？")]),a._v(" "),e("ul",[e("li",[a._v("在某⼀一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回⼀一棵不同的树。React 需要基于这两棵树之间的差别 来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。")])]),a._v(" "),e("h3",{attrs:{id:"diffing算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diffing算法"}},[a._v("#")]),a._v(" diffing算法")]),a._v(" "),e("ul",[e("li",[a._v("算法复杂度O(n)")])]),a._v(" "),e("h3",{attrs:{id:"diff-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-策略"}},[a._v("#")]),a._v(" diff 策略")]),a._v(" "),e("ul",[e("li",[e("ol",[e("li",[a._v("同级比较，Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("拥有不同类型的两个组件将会生成不同的树形结构。例如:div->p, CompA->CompB")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("开发者可以通过 key prop 来暗示哪些⼦元素在不同的渲染下能保持稳定;")])])])]),a._v(" "),e("h3",{attrs:{id:"diff过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff过程"}},[a._v("#")]),a._v(" diff过程")]),a._v(" "),e("ul",[e("li",[a._v("⽐对两个虚拟dom时会有三种操作:删除、替换和更新")]),a._v(" "),e("li",[a._v("vnode是现在的虚拟dom，newVnode是新虚拟dom。")]),a._v(" "),e("li",[a._v("删除:newVnode不存在时")]),a._v(" "),e("li",[a._v("替换:vnode和newVnode类型不同或key不同时")]),a._v(" "),e("li",[a._v("更新:有相同类型和相同key，但vnode和newVnode不同时")])]),a._v(" "),e("h2",{attrs:{id:"fiber是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber是什么"}},[a._v("#")]),a._v(" Fiber是什么？")]),a._v(" "),e("ul",[e("li",[a._v("fiber就是被拆分成块的子任务")]),a._v(" "),e("li",[a._v("fiber是指组件上将要完成或者已经完成的任务，每个组件可以⼀一个或者多个")])]),a._v(" "),e("h3",{attrs:{id:"为什么需要fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要fiber"}},[a._v("#")]),a._v(" 为什么需要fiber")]),a._v(" "),e("ul",[e("li",[a._v("对于⼤型项目，组件树会很大，这个时候递归遍历的成本就会很高，会造成主线程被持续占用，结果就是主线程上的布局、动画等周期性任务就⽆法⽴即得到处理，造成视觉上的卡顿，影响用户体验。")]),a._v(" "),e("li",[a._v("为了解决上面的问题，可以把任务分解\n"),e("ul",[e("li",[a._v("增量渲染(把渲染任务拆分成块，匀到多帧)")]),a._v(" "),e("li",[a._v("更新时能够暂停，终止，复用渲染任务")]),a._v(" "),e("li",[a._v("给不同类型的更新赋予优先级")]),a._v(" "),e("li",[a._v("并发⽅面新的基础能力")]),a._v(" "),e("li",[a._v("更流畅")])])])]),a._v(" "),e("h3",{attrs:{id:"实现fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现fiber"}},[a._v("#")]),a._v(" 实现fiber")]),a._v(" "),e("ul",[e("li",[a._v("Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进⾏增量式渲染。")]),a._v(" "),e("li",[a._v("一个更新过程可能被打断，所以React Fiber一个更新过程被分为两个阶段(Phase):第一个阶段 Reconciliation Phase和第二阶段Commit Phase。")]),a._v(" "),e("li",[a._v("window.requestIdleCallback(callback[, options])")]),a._v(" "),e("li",[a._v("window.requestIdleCallback()⽅法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执⾏，然⽽，如果回调函数指定了执⾏超时timeout，则有可能为了在超时前执⾏函数⽽打乱执⾏顺序。")]),a._v(" "),e("li",[a._v("你可以在空闲回调函数中调⽤requestIdleCallback() ，以便在下一次通过事件循环之前调度另⼀个回调。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);