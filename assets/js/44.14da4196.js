(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{403:function(n,e,t){"use strict";t.r(e);var s=t(44),r=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"异步编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[n._v("#")]),n._v(" 异步编程")]),n._v(" "),t("ul",[t("li",[n._v("回调函数")]),n._v(" "),t("li",[n._v("事件监听")]),n._v(" "),t("li",[n._v("发布/订阅")]),n._v(" "),t("li",[n._v("Promise 对象")]),n._v(" "),t("li",[n._v("Generator 函数")]),n._v(" "),t("li",[n._v("async 函数")])]),n._v(" "),t("h3",{attrs:{id:"回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[n._v("#")]),n._v(" 回调函数")]),n._v(" "),t("ul",[t("li",[n._v("回调函数的优点是简单、容易理解和实现，")]),n._v(" "),t("li",[n._v("缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数")])]),n._v(" "),t("h3",{attrs:{id:"事件监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[n._v("#")]),n._v(" 事件监听")]),n._v(" "),t("ul",[t("li",[n._v("采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生")]),n._v(" "),t("li",[n._v("优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。")]),n._v(" "),t("li",[n._v("缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程")])]),n._v(" "),t("h3",{attrs:{id:"发布-订阅-观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅-观察者模式"}},[n._v("#")]),n._v(" 发布/订阅(观察者模式)")]),n._v(" "),t("ul",[t("li",[n._v("这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行")])]),n._v(" "),t("h3",{attrs:{id:"异步操作的流程控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的流程控制"}},[n._v("#")]),n._v(" 异步操作的流程控制")]),n._v(" "),t("ul",[t("li",[n._v("如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序")]),n._v(" "),t("li",[n._v("串行执行")]),n._v(" "),t("li",[n._v("并行执行")]),n._v(" "),t("li",[n._v("并行与串行的结合")])]),n._v(" "),t("h3",{attrs:{id:"promise-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[n._v("#")]),n._v(" Promise 对象")]),n._v(" "),t("ul",[t("li",[n._v("Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用")]),n._v(" "),t("li",[n._v("Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。")]),n._v(" "),t("li",[n._v("Promise 的最大问题是 "),t("strong",[n._v("代码冗余")]),n._v("，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚")])]),n._v(" "),t("h3",{attrs:{id:"generator-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数"}},[n._v("#")]),n._v(" Generator 函数")]),n._v(" "),t("ul",[t("li",[n._v("Generator 函数的最大特点：可以暂停执行和恢复执行")]),n._v(" "),t("li",[n._v("它可以用看似完全同步的代码（除了yield关键字本身），去书写异步流程")])]),n._v(" "),t("h4",{attrs:{id:"generator-函数可以作为异步编程的完整解决方案原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数可以作为异步编程的完整解决方案原因"}},[n._v("#")]),n._v(" Generator 函数可以作为异步编程的完整解决方案原因：")]),n._v(" "),t("ul",[t("li",[n._v("可以暂停执行和恢复执行")]),n._v(" "),t("li",[n._v("函数体内外的数据交换\n"),t("ul",[t("li",[n._v("next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据")])])]),n._v(" "),t("li",[n._v("错误处理机制\n"),t("ul",[t("li",[n._v("Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误")])])])]),n._v(" "),t("h3",{attrs:{id:"async-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-函数"}},[n._v("#")]),n._v(" async 函数")]),n._v(" "),t("h4",{attrs:{id:"async-函数是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-函数是什么"}},[n._v("#")]),n._v(" async 函数是什么？")]),n._v(" "),t("ul",[t("li",[n._v("async function本质上就是生成器+promise+run(..)模式的语法糖；它们底层的运作方式是一样的！")]),n._v(" "),t("li",[n._v("生成器yield出Promise，然后其控制生成器的迭代器来执行它")]),n._v(" "),t("li",[n._v("组合Promise和看似同步的流程控制代码")])]),n._v(" "),t("h3",{attrs:{id:"async原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async原理"}},[n._v("#")]),n._v(" async原理")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const fs = require('fs')\n\nfunction readFile(filename){\n  return new Promise((resolve, reject)=>{\n    fs.readFile('./store.js', 'utf-8', (err, data)=>{\n      if(!err){\n        return resolve(data)\n      }\n    })\n  })\n}\n\n// async function fn(...args){\n//   const data = await readFile('./store.js')\n//   console.log(data)\n// }\nfn()\nfunction fn(...args){\n  function spawn(genF){\n    return new Promise((resolve, reject)=>{\n      const gen = genF()\n      function step(nextF){\n        let next\n        try{\n          next = nextF()\n        }catch(e){\n          return reject(e)\n        }\n        if(next.done){\n          return resolve(next.value)\n        }\n        Promise.resolve(next.value).then(v=>{\n         step(()=>gen.next(v))\n        }).catch(e=>{\n          step(()=>gen.throw(e))\n        })\n      }\n      step(()=>gen.next(undefined))\n    })\n  }\n  return spawn(function *(){\n    const data = yield readFile('./store.js')\n    console.log(data)\n  })\n}\n")])])]),t("ul",[t("li",[n._v("异步流程控制,执行一组promise函数，执行方式，串行，并行，控制最大并发数执行，使用原生方法，promise方法，即async/await实现")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const fs = require('fs')\n\nfunction promisify(fn, ctx){\n  return (...args) =>{\n    return new Promise((resolve, reject)=>{\n      fn.apply(ctx, [...args, 'utf-8', (err, data)=>{\n        if(err) return reject(err)\n        return resolve(data)\n      }])\n    })\n  }\n}\nconst readFile = promisify(fs.readFile)\n\nasync function fn(filename){\n  const data = await readFile(filename)\n  console.log(data)\n}\n// fn('./proxy.js')\n\nlet items = [1,2,3,4,5]\nlet results = []\n\nfunction series(item){\n  if(item){\n    setTimeout(()=>{\n      console.log('arg: ', item)\n      results.push(item*2)\n      series(items.shift())\n    }, 2000)\n  }else{\n    console.log('results:', results)\n  }\n}\n\nfunction logInOrder(urls){\n  //远程读取所有的urls\n  const textPromises = urls.map(url=>{\n    return fetch(url).then(response=>response.text())\n  })\n  //按次序输出\n  textPromises.reduce((chain, textPromise)=>{\n    return chain.then(()=>textPromise)\n      .then(text=>console.log(text))\n  }, Promise.resolve())\n}\n\nasync function logInOrder(urls){\n  for(const url of urls){\n    const response = await fetch(url)\n    console.log(await response.text())\n  }\n}\nasync function logInOrder(urls){\n  //并发读取远程url\n  const textPromises = urls.map(async url=>{\n    const response = await fetch(url)\n    return response.text()\n  })\n  //按次序输出\n  for(const textPromise of textPromises){\n    console.log(await textPromise)\n  }\n}\n\n\n// series(items.shift())\n\n// for(let i=0,len=items.length; i<len; i++){\n//   setTimeout(()=>{\n//     console.log('arg: ', items[i])\n//     results.push(items[i]*2)\n//     if(results.length === len){\n//       console.log('results:', results)\n//     }\n//   },2000) \n// }\n\nlet running = 0\nlet limit = 2\n\nfunction launcher(){\n  while(running<limit && items.length>0){\n    let item = items.shift()\n    setTimeout(()=>{\n      results.push(item*2)\n      running--\n      launcher()\n      if(running === 0){\n        console.log('results: ', results)\n      }\n    }, 2000)\n    running++\n    console.log('arg: ', item)\n  }\n}\n// launcher()\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let tasks = [1,2,3,4,5,6,7,8,9,10]\nlet limit = 3\nconst readFile = function(file){\n  return new Promise((resolve, reject)=>{\n    setTimeout(()=>{\n      console.log('success', file)\n      resolve(file)\n    }, 5000)\n  })\n}\n\nasync function sendRequest(tasks, limit){\n  return new Promise((resolve, reject)=>{\n    let counter = 0\n    let len = tasks.length\n    let start = async ()=>{\n      let task = tasks.shift()\n      console.log('start: ',task)\n      if(task){\n        await readFile(task)\n        if(counter===len-1){\n          console.log('全部完成')\n          resolve()\n        }else{\n          counter++\n          start()\n        }\n      }\n    }\n    while(limit>0){\n      setTimeout(()=>{\n       start()\n      }, Math.random()*7000)\n      limit--\n    }\n  })\n}\n\nsendRequest(tasks,limit)\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);