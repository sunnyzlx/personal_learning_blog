(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{425:function(t,e,n){"use strict";n.r(e);var r=n(44),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"组件跨层级通信-context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件跨层级通信-context"}},[t._v("#")]),t._v(" 组件跨层级通信 - Context")]),t._v(" "),n("ul",[n("li",[t._v("Context实现祖代组件向后代组件跨层级传值，Vue中的provide & inject来源于Context")]),t._v(" "),n("li",[t._v("react-redux的 Provider ，就是通过 Context 提供⼀个全局态的 store ，路由组件react-router通过 Context 管理路由状态")])]),t._v(" "),n("h3",{attrs:{id:"context-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-api"}},[t._v("#")]),t._v(" Context API")]),t._v(" "),n("h4",{attrs:{id:"react-createcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-createcontext"}},[t._v("#")]),t._v(" React.createContext")]),t._v(" "),n("ul",[n("li",[t._v("创建⼀个 Context 对象。当 React 渲染⼀个订阅了这个 Context 对象的组件，这个组件会从组件树中离⾃身最近的那个匹配的 Provider 中读取到当前的 context 值。")])]),t._v(" "),n("h4",{attrs:{id:"context-provider"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-provider"}},[t._v("#")]),t._v(" Context.Provider")]),t._v(" "),n("ul",[n("li",[t._v("Provider 接收⼀个 value 属性，传递给消费组件，允许消费组件订阅 context 的变化。⼀个 Provider可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使⽤，⾥层的会覆盖外层的数据。")]),t._v(" "),n("li",[t._v("当 Provider 的 value 值发⽣变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部Consumer 组件都不受制于 shouldComponentUpdate 函数，因此当Consumer 组件在其祖先组件退出更新的情况下也能更新。")])]),t._v(" "),n("h4",{attrs:{id:"class-contexttype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#class-contexttype"}},[t._v("#")]),t._v(" Class.contextType")]),t._v(" "),n("ul",[n("li",[t._v("挂载在 class 上的 contextType 属性会被重赋值为⼀个由 React.createContext() 创建的 Context\n对象。这能让你使⽤ this.context 来消费最近 Context 上的那个值。你可以在任何⽣命周期中访问到它，包括 render 函数中。")]),t._v(" "),n("li",[t._v("缺点： 只能订阅单⼀context，且只能用于class组件。")])]),t._v(" "),n("h4",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[t._v("#")]),t._v(" useContext")]),t._v(" "),n("ul",[n("li",[t._v("接收⼀个 context 对象（ React.createContext 的返回值）并返回该 context 的当前值。当前的\ncontext 值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定。只能⽤\n在function组件中。")]),t._v(" "),n("li",[t._v("缺点：只能用于function组件，优点：可以订阅多个context")])]),t._v(" "),n("h4",{attrs:{id:"context-consumer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-consumer"}},[t._v("#")]),t._v(" Context.Consumer")]),t._v(" "),n("ul",[n("li",[t._v("Consumer组件内用{}包裹一个函数，这个函数接收当前的 context 值，返回⼀个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider， value 参数等同于传递给 createContext() 的 defaultValue 。")]),t._v(" "),n("li",[t._v("优点：可以订阅多个context，可用于class组件和function组件，缺点：书写有点麻烦。")])]),t._v(" "),n("h4",{attrs:{id:"注意"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" 注意：")]),t._v(" "),n("ul",[n("li",[t._v("因为 context 会使⽤参考标识（reference identity）来决定何时进⾏渲染，这⾥可能会有⼀些陷阱，当\nprovider 的⽗组件进⾏重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例⼦，当每⼀次\nProvider 重渲染时，以下的代码会重渲染所有下⾯的 consumers 组件，因为 value 属性总是被赋值\n为新的对象：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class App extends React.Component {\n render() {\n   return (\n      <Provider value={{something: 'something'}}>\n        <Toolbar />\n      </Provider>\n   );\n }\n}\n")])])]),n("ul",[n("li",[t._v("为了防⽌这种情况，将 value 状态提升到⽗节点的 state ⾥：")])]),t._v(" "),n("h2",{attrs:{id:"高阶组件-hoc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-hoc"}},[t._v("#")]),t._v(" ⾼阶组件-HOC")]),t._v(" "),n("ul",[n("li",[t._v("定义：⾼阶组件是参数为"),n("strong",[t._v("组件")]),t._v("，返回值为"),n("strong",[t._v("新组件")]),t._v("的"),n("strong",[t._v("函数")])]),t._v(" "),n("li",[t._v("HOC: 是⼀个函数，接收⼀个组件，返回另外⼀个组件")]),t._v(" "),n("li",[t._v("HOC可以链式调⽤")]),t._v(" "),n("li",[t._v("⾼阶组件本身是对装饰器模式的应⽤，⾃然可以利⽤ES7中出现的装饰器语法来更优雅的书写代码。")]),t._v(" "),n("li",[t._v("注意：装饰器只能⽤在class上，执⾏顺序从下往上")]),t._v(" "),n("li",[t._v("组件是将 props 转换为 UI，⽽⾼阶组件是将组件转换为另⼀个组件")])]),t._v(" "),n("h4",{attrs:{id:"使用hoc的注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用hoc的注意事项"}},[t._v("#")]),t._v(" 使⽤HOC的注意事项")]),t._v(" "),n("ul",[n("li",[t._v("不要在 render ⽅法中使⽤ HOC")]),t._v(" "),n("li",[t._v("原因：React 的 diff 算法（称为协调）使⽤组件标识来确定它是应该更新现有⼦树还是将其丢弃并挂载新\n⼦树。 如果从 render 返回的组件与前⼀个渲染中的组件相同（ === ），则 React 通过将⼦树与\n新⼦树进⾏区分来递归更新⼦树。 如果它们不相等，则完全卸载前⼀个⼦树。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("render() {\n // 每次调⽤ render 函数都会创建⼀个新的 EnhancedComponent\n // EnhancedComponent1 !== EnhancedComponent2\n const EnhancedComponent = enhance(MyComponent);\n // 这将导致⼦树每次渲染都会进⾏卸载，和重新挂载的操作！\n return <EnhancedComponent />;\n}\n")])])]),n("ul",[n("li",[t._v("这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有⼦组件的状态丢失。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);