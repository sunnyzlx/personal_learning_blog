(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{417:function(e,n,t){"use strict";t.r(n);var a=t(44),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[e._v("#")]),e._v(" 链表")]),e._v(" "),t("h2",{attrs:{id:"排序链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序链表"}},[e._v("#")]),e._v(" 排序链表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 用js写一个链表的数据结构\n// 声明链表的节点\nclass Node {\n  constructor(value){\n    this.val = value;\n    this.next = undefined;\n  }\n}\n// 声明链表的数据结构\nclass NodeList {\n  constructor(arr){\n    // 声明链表的头部节点\n    let head = new Node(arr.shift())\n    let next = head;\n    arr.forEach(item => {\n      next.next = new Node(item);\n      next = next.next\n    })\n    return head;\n  }\n}\n// 利用快速排序给链表元素排序\n// 声明一个交换两个链表节点值的方法\nlet swap = (p, q) => {\n  let val = p.val;\n  p.val = q.val;\n  q.val = val;\n}\n// 寻找基准元素的节点\nlet partion = (begin, end) =>{\n  let val = begin.val;\n  let p = begin;\n  let q = begin.next;\n  while(q!==end){\n    if(q.val < val){\n      p = p.next;\n      swap(p, q);\n    }\n    q=q.next;\n  }\n  // 让基准元素跑到中间去\n  swap(p, begin)\n  return p;\n}\n\n// 快排序\nexport default function sort(begin, end){\n  if(begin!==end){\n    let part = partion(begin, end)\n    sort(begin, part)\n    sort(part, end)\n  }\n}\nexport {\n  Node,\n  NodeList\n}\n")])])]),t("h3",{attrs:{id:"删除链表节点-203"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除链表节点-203"}},[e._v("#")]),e._v(" 删除链表节点(203)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var removeElements = function(head, val) {\n  let ele = {\n    next: head\n  }\n  let cur = ele\n  while(cur.next){\n    if(cur.next.val===val){\n      cur.next = cur.next.next\n    }else{\n      cur = cur.next\n    }\n  }\n  return ele.next\n};\n")])])]),t("h3",{attrs:{id:"反转链表-206"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反转链表-206"}},[e._v("#")]),e._v(" 反转链表（206）")]),e._v(" "),t("ul",[t("li",[e._v("https://leetcode-cn.com/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-by-alexer-660/")]),e._v(" "),t("li",[e._v("迭代法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n  let [prev, cur] = [null, head]\n  while(cur){\n    let tmp = cur.next\n    cur.next = prev\n    prev = cur\n    cur = tmp\n  }\n  return prev\n};\n")])])]),t("ul",[t("li",[e._v("尾递归法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n  return reverse(null, head)\n};\nfunction reverse(prev, cur){\n  if(!cur) return prev\n  let tmp = cur.next\n  cur.next = prev\n  return reverse(cur, tmp)\n}\n")])])]),t("ul",[t("li",[e._v("递归")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n  if(!head||!head.next) return head\n  let next = head.next\n  let reverseHead = reverseList(next)\n  head.next = null\n  next.next = head\n  return reverseHead\n};\n\n\nvar reverseList = function(head) {\n    // 如果测试用例只有一个节点 或者 递归到了尾节点，返回当前节点 \n    if(!head || !head.next) return head;\n    // 存储当前节点的下一个节点\n    let next = head.next;\n    let reverseHead = reverseList(next);\n    // 断开 head ，如图闪电⚡️标记处\n    head.next = null;\n    // 反转，后一个节点连接当前节点\n    next.next = head;\n    return reverseHead;\n};\n")])])]),t("h2",{attrs:{id:"环形链表-141"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环形链表-141"}},[e._v("#")]),e._v(" 环形链表(141)")]),e._v(" "),t("ul",[t("li",[e._v("哈希表")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var hasCycle = function(head) {\n  let map = new Map()\n  while(head!==null){\n    if(map.has(head)){\n      return true\n    }\n    map.set(head, true)\n    head = head.next\n  }\n  return false\n};\n")])])]),t("ul",[t("li",[e._v("快慢指针")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var hasCycle = function(head) {\n  let slow = head\n  let fast = head\n  while(fast && fast.next){\n    slow = slow.next\n    fast = fast.next.next\n    if(slow === fast){\n      return true\n    }\n  }\n  return false\n};\n")])])]),t("h2",{attrs:{id:"链表入环点-142"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表入环点-142"}},[e._v("#")]),e._v(" 链表入环点（142）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var detectCycle = function (head) {\n  let slowP = head, fastP = head // 都从头节点出发\n  while (fastP) {                // head就是null了，没有入环点，直接返回null\n    if (fastP.next == null) return null // fastP.next为null也说明无环\n    slowP = slowP.next           // 慢指针走一步\n    fastP = fastP.next.next      // 快指针走两步\n    if (slowP == fastP) {        // 首次相遇\n      fastP = head               // 让快指针回到头节点\n      while (true) {             // 开启循环，让快慢指针相遇\n        if (slowP == fastP) {    // 相遇，地点发生在入环处\n          return slowP           // 返回出指针的位置\n        }\n        fastP = fastP.next       // 快慢指针都走一步\n        slowP = slowP.next\n      }\n    }\n  }\n  return null\n};\n")])])]),t("h2",{attrs:{id:"链表-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表-2"}},[e._v("#")]),e._v(" 链表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Node{\n  constructor(element){\n    this.ele = element;\n    this.next = null\n  }\n}\nclass LinkNodeList{\n  constructor(){\n    this.head = null;\n    this.length = 0;\n  }\n  append(ele){\n    let node = new Node(ele)\n    let cur\n    if(this.head==null){\n      this.head = node\n    }else{\n      cur = this.head\n      while(cur.next){\n        cur = cur.next\n      }\n      cur.next = node\n    }\n    this.length++\n  }\n  toString(){\n    let cur = this.head\n    let ret = [];\n    while(cur){\n      ret.push(cur.ele)\n      cur = cur.next\n    }\n    return ret.join('==>')\n  }\n}\n")])])]),t("p",[e._v("//链表反转反复看")])])}),[],!1,null,null,null);n.default=r.exports}}]);