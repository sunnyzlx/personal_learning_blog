(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{369:function(n,e,t){"use strict";t.r(e);var a=t(44),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"js高频手写题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js高频手写题"}},[n._v("#")]),n._v(" JS高频手写题")]),n._v(" "),t("h3",{attrs:{id:"_1-浅克隆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-浅克隆"}},[n._v("#")]),n._v(" 1. 浅克隆")]),n._v(" "),t("ul",[t("li",[n._v("浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function shallowClone(o){\n  const obj = {}\n  for(let i in o){\n    obj[i] = o[i]\n  }\n  return obj;\n}\nvar newObj = Object.assign(target, source)\nslice,concat\n")])])]),t("h3",{attrs:{id:"_2-深克隆-deepclone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-深克隆-deepclone"}},[n._v("#")]),n._v(" 2.深克隆(deepClone)")]),n._v(" "),t("ul",[t("li",[n._v("简单版")]),n._v(" "),t("li",[n._v("JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const newObj = JSON.parse(JSON.stringify(oldObj));\n")])])]),t("ul",[t("li",[n._v("局限性:\n"),t("ul",[t("li",[t("ol",[t("li",[n._v("他无法实现对函数 、RegExp等特殊对象的克隆")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("会抛弃对象的constructor,所有的构造函数会指向Object")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[n._v("对象有循环引用,会报错")])])]),n._v(" "),t("li",[n._v("对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。")])])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/ 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person('Messi');\n\n// 函数\nfunction say() {\n  console.log('hi');\n};\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp('ab+c', 'i'),\n  d: Messi\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON\n// 对象的循环引用会抛出错误\n")])])]),t("ul",[t("li",[n._v("面试版")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n* deep clone\n* @param {[type]} parent object 需要进行克隆的对象 * @return {[type]} 深克隆后的对象\n*/\nconst clone = (parent) => {\n  //判断类型\n  const isType = (obj, type) => {\n    if(typeof obj !== 'object') return false;\n    const typeString = Object.prototype.toString.call(obj);\n    let flag;\n    switch(type){\n      case 'Array':\n        flag = typeString === '[object Array]';\n        break;\n      case 'Date':\n        flag = typeString === '[object Date]';\n        break;\n      case 'RegExp':\n        flag = typeString === '[object RegExp]';\n        break;\n      default:\n        flag = false;\n    }\n    return flag;\n  }\n  // 处理正则\n  const getRegExp = (re) => {\n    var flags = \"\";\n    if (re.global) flags += \"g\";\n    if (re.ignoreCase) flags += \"i\"; if (re.multiline) flags += \"m\"; return flags;\n  }\n  // 维护储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = parent => {\n    if(parent === null) return null;\n    if(typeof parent !== 'object') return parent;\n\n    let child, proto;\n\n    if(isType(parent, 'Array')){\n      // 对数组做特殊处理\n      child = []\n    }else if(isType(parent, 'RegExp')){\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n    }else if(isType(parent, 'Date')){\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    }else{\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent); \n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n\n    }\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 \n      return children[index];\n    } \n\n    parents.push(parent); \n    children.push(child);\n\n    for (let i in parent) { \n      // 递归\n      child[i] = _clone(parent[i]); \n    }\n    return child;\n  }\n  return _clone(parent);\n}\n\n\nclone({\n  a: 'aaa',\n  b: ['1','2','3'],\n  c: {\n    d: '111'\n  },\n  e: function(){\n    return '555'\n  }\n})\n\nlet obj2 = {\n  // a: undefined,\n  // b: function(){},\n  // c: /ab/i,\n  // d: [undefined],\n  // e: p,\n  a: new Number(1),\n  b: new Boolean(false),\n  c: new String(1),\n  // a: new Set([1, 2, 3, 4, 4]),\n  // b: new Map({p: 'Hello World'}),\n  // c: Promise.resolve(1)\n}\n//重写\nlet deepClone = (parent) => {\n  //维护两个循环引用的数组\n  const parents = []\n  const children = []\n  let initChild = (parent) => {\n    let child, proto;\n    let oType = Object.prototype.toString.call(parent).slice(8,-1).toLowerCase()\n    switch(oType){\n      case 'array':\n        child = []\n        break\n      case 'regexp':\n        child = new RegExp(parent.source, parent.flags)\n        break\n      case 'date':\n        child = new Date(parent.getTime())\n        break\n      case 'object':\n        proto = Object.getPrototypeOf(parent)\n        child = Object.create(proto)\n        break\n      default:\n        child = parent\n    }\n    return child;\n  }\n  let _clone = (parent) => {\n    if(parent === null) return null\n    if(typeof parent !== 'object') return parent\n\n    let child = initChild(parent)\n    \n    //处理循环引用的问题\n    let index = parents.indexOf(parent)\n    if(index!==-1){\n      return children[index]\n    }\n    parents.push(parent)\n    children.push(child)\n\n    for(let i in parent){\n      child[i] = _clone(parent[i])\n    }\n    return child\n  }\n  return _clone(parent)\n}\n")])])]),t("ul",[t("li",[n._v("局限性:\n"),t("ul",[t("li",[t("ol",[t("li",[n._v("一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间")])])]),n._v(" "),t("li",[n._v("在生产环境中最好用lodash的深克隆实现.")])])])]),n._v(" "),t("h3",{attrs:{id:"_2-实现防抖函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现防抖函数"}},[n._v("#")]),n._v(" 2.实现防抖函数")]),n._v(" "),t("ul",[t("li",[n._v("防抖函数原理:在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 防抖函数\nconst debounce = (fn, delay) => {\n  let timer = null;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n};\n")])])]),t("ul",[t("li",[n._v("适用场景：\n"),t("ul",[t("li",[n._v("按钮提交场景：防止多次提交按钮，只执行最后提交的一次")]),n._v(" "),t("li",[n._v("服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似")]),n._v(" "),t("li",[n._v("生产环境请用lodash.debounce")])])])]),n._v(" "),t("h3",{attrs:{id:"_3-实现节流函数-throttle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-实现节流函数-throttle"}},[n._v("#")]),n._v(" 3.实现节流函数（throttle）")]),n._v(" "),t("ul",[t("li",[n._v("防抖函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 节流函数\nconst throttle = (fn, delay = 500) => {\n  let flag = true;\n  return (...args) => {\n    if (!flag) return;\n    flag = false;\n    setTimeout(() => {\n      fn.apply(this, args);\n      flag = true;\n    }, delay);\n  };\n};\n")])])]),t("ul",[t("li",[n._v("适用场景：\n"),t("ul",[t("li",[n._v("拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动")]),n._v(" "),t("li",[n._v("缩放场景：监控浏览器resize")]),n._v(" "),t("li",[n._v("动画场景：避免短时间内多次触发动画引起性能问题")])])])]),n._v(" "),t("h3",{attrs:{id:"_4-实现event-event-bus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-实现event-event-bus"}},[n._v("#")]),n._v(" 4.实现Event(event bus)")]),n._v(" "),t("ul",[t("li",[n._v("event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础")]),n._v(" "),t("li",[n._v("简单版")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class EventEmitter {\n  constructor() {\n    this._events = this._events || new Map(); // 储存事件/回调键值对\n    this._maxListeners = this._maxListeners || 10; // 设立监听上限\n  }\n}\n\n// 触发名为type的事件\nEventEmitter.prototype.emit = function(type, ...args) {\n  let handler;\n  // 从储存事件键值对的this._events中获取对应事件回调函数\n  handler = this._events.get(type);\n  if (args.length > 0) {\n    handler.apply(this, args);\n  } else {\n    handler.call(this);\n  }\n  return true;\n};\n\n// 监听名为type的事件\nEventEmitter.prototype.addListener = function(type, fn) {\n  // 将type事件以及对应的fn函数放入this._events中储存\n  if (!this._events.get(type)) {\n    this._events.set(type, fn);\n  }\n};\n")])])]),t("ul",[t("li",[n._v("面试版：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class EventEmitter {\n  constructor() {\n    this._events = this._events || new Map(); // 储存事件/回调键值对\n    this._maxListeners = this._maxListeners || 10; // 设立监听上限\n  }\n}\n\n// 触发名为type的事件\nEventEmitter.prototype.emit = function(type, ...args) {\n  let handler;\n  handler = this._events.get(type);\n  if (Array.isArray(handler)) {\n    // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (args.length > 0) {\n        handler[i].apply(this, args);\n      } else {\n        handler[i].call(this);\n      }\n    }\n  } else {\n    // 单个函数的情况我们直接触发即可\n    if (args.length > 0) {\n      handler.apply(this, args);\n    } else {\n      handler.call(this);\n    }\n  }\n\n  return true;\n};\n\n// 监听名为type的事件\nEventEmitter.prototype.addListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n  if (!handler) {\n    this._events.set(type, fn);\n  } else if (handler && typeof handler === "function") {\n    // 如果handler是函数说明只有一个监听者\n    this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存\n  } else {\n    handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可\n  }\n};\n\nEventEmitter.prototype.removeListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n\n  // 如果是函数,说明只被监听了一次\n  if (handler && typeof handler === "function") {\n    this._events.delete(type, fn);\n  } else {\n    let position;\n    // 如果handler是数组,说明被监听多次要找到对应的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (handler[i] === fn) {\n        position = i;\n      } else {\n        position = -1;\n      }\n    }\n    // 如果找到匹配的函数,从数组中清除\n    if (position !== -1) {\n      // 找到数组对应的位置,直接清除此回调\n      handler.splice(position, 1);\n      // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n      if (handler.length === 1) {\n        this._events.set(type, handler[0]);\n      }\n    } else {\n      return this;\n    }\n  }\n};\n')])])]),t("h3",{attrs:{id:"_5-实现json-parse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现json-parse"}},[n._v("#")]),n._v(" 5.实现JSON.parse")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var json = \'{"name":"cxk", "age":25}\';\nvar obj = eval("(" + json + ")");\n')])])]),t("ul",[t("li",[n._v("此方法属于黑魔法，极易容易被xss攻击，还有一种new Function大同小异。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);