(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{397:function(e,n,t){"use strict";t.r(n);var r=t(44),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" promise")]),e._v(" "),t("ul",[t("li",[e._v("https://juejin.im/post/6844903632203153415")]),e._v(" "),t("li",[e._v("https://juejin.im/post/6844904023988895757")]),e._v(" "),t("li",[e._v("https://juejin.im/post/6844903591518404622")]),e._v(" "),t("li",[e._v("https://juejin.im/post/6844903763178684430#heading-9")])]),e._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("ul",[t("li",[e._v("Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、race、reject、resolve这几个方法，原型上有then、catch、finally等方法")]),e._v(" "),t("li",[e._v("Promise 是一个对象，从它可以获取异步操作的结果。这个对象有2个特点，3种状态；")])]),e._v(" "),t("h2",{attrs:{id:"_2个特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2个特点"}},[e._v("#")]),e._v(" 2个特点")]),e._v(" "),t("ul",[t("li",[e._v("对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。")]),e._v(" "),t("li",[e._v("一旦状态改变，就不会再变，任何时候都可以得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。")])]),e._v(" "),t("h2",{attrs:{id:"_3种状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3种状态"}},[e._v("#")]),e._v(" 3种状态")]),e._v(" "),t("ul",[t("li",[e._v("pending（进行中）、fulfilled（已成功）和rejected（已失败）")])]),e._v(" "),t("h2",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),t("ul",[t("li",[e._v("有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数")])]),e._v(" "),t("h2",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),t("ul",[t("li",[e._v("无法取消Promise，一旦新建它就会立即执行，无法中途取消")]),e._v(" "),t("li",[e._v("如果不设置回调函数，Promise内部抛出的错误，不会反应到外部")]),e._v(" "),t("li",[e._v("当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）")])]),e._v(" "),t("h2",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[e._v("#")]),e._v(" 应用")]),e._v(" "),t("h3",{attrs:{id:"_1-手写promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-手写promise"}},[e._v("#")]),e._v(" 1.手写promise")]),e._v(" "),t("ul",[t("li",[e._v("https://zhuanlan.zhihu.com/p/21834559")]),e._v(" "),t("li",[e._v("简版"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 手写promise\nclass Promise1{\n  constructor(fn){\n    // 初始化state为等待态\n    this.state = 'pending'\n    // 初始化成功的参数\n    this.value = undefined\n    // 初始化失败的参数\n    this.reason = undefined\n    // resolve调用，state变为成功态，并将要传递的参数，挂到this.value上，方便回调onFulfilled调用\n    let resolve = (value) => {\n      if(this.state === 'pending'){\n        this.state = 'resolved'\n        this.value = value\n      }\n    }\n    // reject调用，state变为失败态，并将要传递的参数，挂到this.reason上，方便回调onRejected调用\n    let reject = (reason) => {\n      if(this.state === 'pending'){\n        this.state = 'rejected'\n        this.reason = reason\n      }\n    }\n    // 自动执行函数\n    try{\n      fn(resolve, reject)\n    }catch(err){\n      reject(err)\n    }\n  }\n\n  then(onFulfilled, onRejected){\n    if(this.state === 'resolved'){\n      onFulfilled(this.value)\n    }\n    if(this.state === 'rejected'){\n      onRejected(this.reason)\n    }\n  }\n}\n\n\nnew Promise1(function(resolve, reject){\n  resolve(2)\n  console.log(0)\n}).then(console.log)\n// 0 2\n")])])])]),e._v(" "),t("li",[e._v("复杂版")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  class Promise {\n  constructor(executor){\n    this.state = 'pending'\n    this.value = undefined\n    this.reason = undefined\n    this.onResolvedCallbacks = []\n    this.onRejectedCallbacks = []\n    let resolve = value => {\n      if(this.state === 'pending'){\n        this.state = 'fulfilled'\n        this.value = value\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n    let reject = value => {\n      if(this.state === 'pending'){\n        this.state = 'rejected'\n        this.reason = value\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try {\n      executor(resolve,reject)\n    }catch(err){\n      reject(err)\n    }\n  }\n  then(onFulfilled, onRejected){\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value\n    onRejected = typeof onRejected === 'function' ? onRejected : reason =>{ throw reason }\n    let promise2 = new Promise((resolve, reject)=>{\n      if(this.state === 'fulfilled'){\n        setTimeout(() => {\n          try {\n            let x = onFulfilled(this.value)\n            resolvePromise(promise2,x,resolve,reject)\n          }catch(err){\n            reject(err)\n          }\n        },0)\n      }\n      if(this.state === 'rejected'){\n        setTimeout(() => {\n          try {\n            let x = onRejected(this.reason)\n            resolvePromise(promise2,x,resolve,reject)\n          }catch(err){\n            reject(err)\n          }\n        },0)\n      }\n      if(this.state === 'pending'){\n        this.onFulfilledCallbacks.push(()=>{\n          setTimeout(() => {\n            try {\n              let x = onFulfilled(this.value)\n              resolvePromise(promise2,x,resolve,reject)\n            }catch(err){\n              reject(err)\n            }\n          },0)\n        })\n        this.onRejectedCallbacks.push(()=>{\n          setTimeout(() => {\n            try {\n              let x = onRejected(this.reason)\n              resolvePromise(promise2,x,resolve,reject)\n            }catch(err){\n              reject(err)\n            }\n          },0)\n        })\n        \n      }\n    })\n    return promise2;\n  }\n  catch(fn){\n    return this.then(null, fn)\n  }\n}\n// 实现。then的链式调用\nfunction resolvePromise(promise2,x,resolve,reject){\n  if(x === promise2){\n    return reject(new TypeError('Chaining cycle detected for promise'))\n  }\n  let called;\n  if(x!==null && (typeof x === 'object' || typeof x === 'function')){\n    try {\n      let then = x.then\n      if(typeof then === 'function'){\n        then.call(x, y => {\n          if(called) return\n          called = true\n          resolvePromise(promise2, y, resolve, reject)\n        }, err => {\n          if(called) return\n          called = true\n          reject(err)\n        })\n      }else{\n        resolve(x)\n      }\n    }catch(e){\n      if(called) return\n      called = true\n      reject(e)\n    }\n  }else{\n    resolve(x)\n  }\n}\n\n//resolve方法\nPromise.resolve = function(val){\n  return new Promise((resolve,reject) => {\n    resolve(val)\n  })\n}\n//reject方法\nPromise.reject = function(val){\n  return new Promise((resolve,reject) => {\n    reject(val)\n  })\n}\n//race方法\nPromise.race = function(promises){\n  return new Promise((resolve, reject)=>{\n    promises.forEach(promise => {\n      promise.then(resolve,reject)\n    })\n  })\n}\n// all方法\nPromise.all = function(promises){\n  let arr = [], index=0;\n  let len = promises.length\n  return new Promise((resolve,reject) => {\n    for(let i=0; i<len; i++){\n      promises[i].then(data => {\n        index++\n        arr[i] = data;\n        if(index === len){\n          return resolve(arr)\n        }\n      }, reject)\n    }\n  })\n}\n")])])]),t("h3",{attrs:{id:"_2-实现一个延时函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现一个延时函数"}},[e._v("#")]),e._v(" 2.实现一个延时函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sleep(time){\n  return new Promise(function(resolve,reject){\n    setTimeout(() => {\n      resolve(true)\n    }, time*1000)\n  })\n}\n")])])]),t("h3",{attrs:{id:"_3-实现一个retry函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-实现一个retry函数"}},[e._v("#")]),e._v(" 3.实现一个retry函数")]),e._v(" "),t("ul",[t("li",[e._v("promise.retry 的作用是执行一个函数，如果不成功最多可以尝试 times 次。传参需要三个变量，所要执行的函数，尝试的次数以及延迟的时间。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function retry(fn, times, delay){\n  return new Promise((resolve, reject)=>{\n    let errors = []\n    function attempt(){\n      if(times===0){\n        reject(errors)\n      }else{\n        fn().then(v=>resolve(v))\n          .catch(e=>{\n            errors.push(e)\n            times--;\n            setTimeout(() => attempt(),delay)\n          })\n      }\n    }\n    attempt()\n  })\n}\n")])])]),t("h3",{attrs:{id:"_4-将node的回调中同步的callback包装为promise形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-将node的回调中同步的callback包装为promise形式"}},[e._v("#")]),e._v(" 4.将node的回调中同步的callback包装为promise形式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("nodeGet(param, function (err, data) { })\n  // 转化成promise形式\n  function nodeGetAysnc(param) {\n    return new Promise((resolve, reject) => {\n      nodeGet(param, function (err, data) {\n        if (err !== null) return reject(err)\n        resolve(data)\n      })\n  })}\n// 按照上面的思路，即可写出通用版的形式。\nfunction promisify(fn,context){\n  return (...args) => {\n    return new Promise((resolve,reject) => {\n        fn.apply(context,[...args,(err,res) => {\n            return err ? reject(err) : resolve(res)\n        }])\n    })\n  }\n}\n\nfunction promisify(fn, ctx){\n  return (...args) => {\n    return new Promise(function(resolve,reject){\n      fn.apply(ctx, [...args, (err,res) => {\n        return err ? reject(err) : resolve(res)\n      }])\n    })\n  }\n}\n")])])]),t("h3",{attrs:{id:"_5-异步加载图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步加载图片"}},[e._v("#")]),e._v(" 5.异步加载图片")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function loadImageAsync(url){\n  return new Promise(function(resolve,reject){\n    const image = new Image()\n    image.onload = function(){\n      resolve(image)\n    }\n    image.onerror = function(){\n      reject(new Error('could not load image at'+url))\n    }\n    image.src = url\n  })\n}\n")])])]),t("h3",{attrs:{id:"_6-用promise对象实现的-ajax-操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-用promise对象实现的-ajax-操作"}},[e._v("#")]),e._v(" 6.用Promise对象实现的 Ajax 操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const getJSON = function(url){\n  return new Promise(function(resolve,reject){\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url)\n    xhr.setRequestHeader('Accept','application/json')\n    xhr.responseType = 'json';\n    xhr.onreadystatechange = function(){\n      if(xhr.readyState !== 4){\n        return;\n      }\n      if(xhr.status === 200){\n        resolve(xhr.responseText)\n      }else{\n        reject(new Error(this.statusText))\n      }\n    }\n    xhr.send()\n  })\n}\n\ngetJSON('./posts.json').then()\n")])])]),t("h3",{attrs:{id:"_7-promise异步流程控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-promise异步流程控制"}},[e._v("#")]),e._v(" 7.promise异步流程控制")]),e._v(" "),t("ul",[t("li",[e._v("https://juejin.im/post/59cdb6526fb9a00a4e67c7fb#heading-8")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function loadImg(url){\n  return new Promise(function(resolve,reject){\n    const img = new Image()\n    img.onload = function(){\n      resolve(img)\n    }\n    img.onerror = reject\n    img.src = url\n  })\n}\n\nlet promise = Promise.resolve()\nfor(let i=0,len=urls.length; i<len;i++){\n  promise = promise.then(()=> loadImg(urls[i]))\n                   .then(()=> addToHtml)\n}\n\nurls.reduce((promise,url) =>{\n  return promise.then(() => loadImg(url))\n                .then(()=> addToHtml)\n}, Promise.resolve()).then(() => {\n  document.querySelector('.loading').style.display = 'none'\n})\n\n\nfunction syncLoad(index){\n  if(index>=urls.length) return Promise.resolve()\n  loadImg(urls[index])\n    .then(img => {\n      addToHtml(img)\n      return syncLoad(index+1)\n    })\n}\nsyncLoad(0)\n  .then(()=>{\n    document.querySelector('.loading').style.display = 'none'\n})\n\nfunction syncLoad(fn, arr, handler){\n  const errors = []\n  return arr.reduce((promise, url)=>{\n    return promise.then(() => fn(url))\n                  .then((img)=> handler(img))\n                  .catch((err)=>{\n                    console.log(err)\n                    errors.push(url)\n                  })\n\n  }, Promise.resolve()).then(() => {\n    document.querySelector('.loading').style.display = 'none'\n  }).catch(console.log)\n}\n\n\nsyncLoad(imgLoad, urls, addToHtml)\n  .then(()=>{\n    document.querySelector('.loading').style.display = 'none'\n  })\n  .catch(console.log)\n\nconst promises = urls.map(loadImg)\nPromise.all(promises)\n  .then(imgs =>{\n    imgs.forEach(addToHtml)\n    document.querySelector('.loading').style.display = 'none'\n  })\n  .catch(err => {\n    console.log(err)\n  })\n\n\nconst promises = urls.map(loadImg)\npromises.reduce((task, imgPromise)=>{\n  task.then(() => imgPromise).then(()=>addToHtml)\n}, Promise.resolve())\n")])])]),t("h3",{attrs:{id:"_8-控制最大并发数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-控制最大并发数"}},[e._v("#")]),e._v(" 8.控制最大并发数")]),e._v(" "),t("ul",[t("li",[e._v("微信小程序最一开始对并发数限制为5个，后来升级到10个，如果超过10个会被舍弃。后来微信小程序升级为不限制并发请求，但超过10个会排队机制。也就是当同时调用的请求超过 10 个时，小程序会先发起 10 个并发请求，超过 10 个的部分按调用顺序进行排队，当前一个请求完成时，再发送队列中的下一个请求。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function limitLoad(urls, handler, limit){\n  const newUrls = [].concat(urls)\n  let count = 0\n  const promises = []\n  function load(){\n    if(newUrls.length<=0 || count >limit) return\n    count+=1\n    return handler(newUrls.shift())\n      .catch(err=>{\n        console.log(err)\n      })\n      .then(() => {\n        count-=1\n      })\n      .then(() =>{\n        load()\n      })\n  }\n  for(let i=0,len=newUrls.length; i<limit && i<len;i++){\n    promises.push(load())\n  }\n  return Promise.all(promises)\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function concurrentPoll(){\n    this.tasks = [];\n    this.max = 10;\n    setTimeout(() => {\n        this.run()\n    },0)\n}\n\nconcurrentPoll.prototype.addTask = function(task){\n    this.tasks.push(task)\n}\n\nconcurrentPoll.prototype.run = function(){\n    if(this.tasks.length == 0){\n        return\n    }\n    var min = Math.min(this.tasks.length, max);\n    for(var i = 0; i < min; i++){\n        this.max--;\n        var task = this.tasks.shift();\n        task().then((res) => {\n            console.log(res)\n        }).catch((err) => {\n            console.log(err)\n        }).finally(() => {\n            this.max++;\n            this.run();\n        })\n    }\n}\n")])])]),t("h3",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),t("ul",[t("li",[e._v("前端很常见是下面一个场景，我们需要实现一个用户修改头像的功能。首先我们需要将一张图片压缩并提交给后端，后端返回该图片保存的 url，前端拿保存的 url 和用户 id 提交给服务器来修改用户头像。\n"),t("ul",[t("li",[e._v("异步一：加载图片")]),e._v(" "),t("li",[e._v("异步二：压缩图片")]),e._v(" "),t("li",[e._v("异步三：上传图片")]),e._v(" "),t("li",[e._v("异步四：提交保存")])])]),e._v(" "),t("li",[e._v("大概代码实现")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.all([func1(), func2(), func3()])\n  .then(([result1, result2, result3])=>{})\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);