(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{443:function(a,t,s){"use strict";s.r(t);var e=s(44),l=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"webpack基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack基础"}},[a._v("#")]),a._v(" webpack基础")]),a._v(" "),s("ul",[s("li",[a._v("入口entry")]),a._v(" "),s("li",[a._v("输出output")]),a._v(" "),s("li",[a._v("loader")]),a._v(" "),s("li",[a._v("插件plugins")])]),a._v(" "),s("h2",{attrs:{id:"entry"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#entry"}},[a._v("#")]),a._v(" entry")]),a._v(" "),s("ul",[s("li",[a._v("入口起点，用于指示webpack，应该将哪个模块，作为构建其内部依赖图的开始")])]),a._v(" "),s("h3",{attrs:{id:"用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[a._v("#")]),a._v(" 用法")]),a._v(" "),s("ul",[s("li",[a._v("单个入口语法\n"),s("ul",[s("li",[a._v("entry为 描述文件绝对路径的字符串，默认值为 './src'")]),a._v(" "),s("li",[a._v("简单，但可扩展性不好")])])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 简写\nconst config = {\n  entry: './path/to/entry/file.js'\n}\n// 正常 (默认的键名为main)\nconst config = {\n  entry: {\n    main: './path/to/entry/file.js'\n  }\n}\n")])])]),s("ul",[s("li",[a._v("对象语法\n"),s("ul",[s("li",[a._v("繁琐，但是可扩展性好")])])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const config = {\n  entry: {\n    app: './src/app.js',\n    vendors: './src/vendors.js'\n  }\n}\n")])])]),s("h3",{attrs:{id:"常用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用场景"}},[a._v("#")]),a._v(" 常用场景")]),a._v(" "),s("ul",[s("li",[a._v("分离应用程序(app)与第三方库(vendor)的入口")]),a._v(" "),s("li",[a._v("创建多页面应用程序")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const config = {\n  entry: {\n    app: './src/app.js',\n    vendors: './src/vendors.js\n  }\n}\n// 可以使用CommonsChunkPlugin插件，从应用程序bundle提取vendor引用到 vendor bundle，以实现长效缓存\n// v4 中CommonsChunkPlugin已被替换\nconst config = {\n  entry: {\n    pageOne: './src/pageOne/index.js',\n    pageTwo: './src/pageTwo/index.js',\n    pageThree: './src/pageThree/index.js'\n  }\n}\n// 在多页应用中，每当页面跳转时，服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载\n// 使用CommonsChunkPlugin可以为每个页面间的应用程序共享代码创建bundle\n// 多页应用中，由于入口起点增多，我们可以复用入口起点之间的大量代码/模块，以提升性能\n")])])]),s("h2",{attrs:{id:"output"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[a._v("#")]),a._v(" output")]),a._v(" "),s("ul",[s("li",[a._v("输出output, 告诉webpack在哪里输出它所创建的 bundles，以及如何命名这些文件, 默认值为 ./dist")]),a._v(" "),s("li",[a._v("即使存在多个入口起点，也只指定一个输出")])]),a._v(" "),s("h3",{attrs:{id:"用法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用法-2"}},[a._v("#")]),a._v(" 用法")]),a._v(" "),s("ul",[s("li",[a._v("output是一个对象")]),a._v(" "),s("li",[a._v("filename，定义输出文件的文件名")]),a._v(" "),s("li",[a._v("path，定义目标输出目录的绝对路径")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const config = {\n  output = {\n    filename: 'bundle.js',\n    path: './dist'\n  }\n}\n")])])]),s("h3",{attrs:{id:"多个入口起点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多个入口起点"}},[a._v("#")]),a._v(" 多个入口起点")]),a._v(" "),s("ul",[s("li",[a._v("如果配置了多个单独的'chunk'(例如使用多个入口起点或使用CommonsChunkPlugin插件时), 应使用占位符，确保每个输出文件都具有唯一的名称, 如果不做区分，将会报错，name或者hash都可以")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const config = {\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n}\n")])])]),s("h3",{attrs:{id:"使用cdn和资源hash的复杂示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用cdn和资源hash的复杂示例"}},[a._v("#")]),a._v(" 使用CDN和资源hash的复杂示例 ？？")]),a._v(" "),s("ul",[s("li",[a._v("还有一种使用场景，我们会把打包生成的html文件给后端，作为后端的一个入口文件，把其他静态资源js，css,图片等上传到CDN域名下，这样打包生成的html文件，在引用静态资源时，就需要加上CDN的域名地址，可以通过配置publicPath来实现自动生成")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('const config = {\n  output = {\n    path: "/home/proj/cdn/assets/[hash]",\n    publicPath: "http://cdn.example.com/assets/[hash]/"   \n  }\n}\n')])])]),s("ul",[s("li",[a._v("在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 "),s("strong",[a._v("webpack_public_path")]),a._v("。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("__webpack_public_path__ = myRuntimePublicPath\n")])])]),s("h2",{attrs:{id:"loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[a._v("#")]),a._v(" loader")]),a._v(" "),s("ul",[s("li",[a._v("主要用于将非JS模块进行转换，方便webpack打包")]),a._v(" "),s("li",[a._v("使用方式：3种，配置，内联，cli(shell命令)\n"),s("ul",[s("li",[a._v("推荐使用配置方式，优点：代码简洁，同时可以对各个loader有个全局概览")])])]),a._v(" "),s("li",[a._v("通过（loader）预处理函数，用户可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。")])]),a._v(" "),s("h3",{attrs:{id:"使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),s("ul",[s("li",[a._v("module, 是个对象")]),a._v(" "),s("li",[a._v("rules, 是个数组")]),a._v(" "),s("li",[a._v("每一条rule都是一个对象，包含两个必须属性：\n"),s("ul",[s("li",[a._v("test，匹配需要转换的文件；")]),a._v(" "),s("li",[a._v("use，使用哪个loader进行转换；")])])])]),a._v(" "),s("h3",{attrs:{id:"loader特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader特性"}},[a._v("#")]),a._v(" loader特性")]),a._v(" "),s("ul",[s("li",[a._v("支持链式传递，一组链式的 loader 将按照相反的顺序执行，loader的执行顺序是从下到上，从右到左，在最后一个 loader，返回 webpack 所预期的 JavaScript。")]),a._v(" "),s("li",[a._v("loader可以是同步的，也可以是异步的")])]),a._v(" "),s("h3",{attrs:{id:"如何编写-loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何编写-loader"}},[a._v("#")]),a._v(" 如何编写 loader？？？")]),a._v(" "),s("ul",[s("li",[a._v("loader 模块需要导出为一个函数")])]),a._v(" "),s("h3",{attrs:{id:"静态资源打包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态资源打包"}},[a._v("#")]),a._v(" 静态资源打包")]),a._v(" "),s("ul",[s("li",[a._v("图片资源\n"),s("ul",[s("li",[a._v("file-loader, 将文件发送到输出文件夹，并返回（相对）URL")]),a._v(" "),s("li",[a._v("url-loader, 像file loader一样工作，但如果文件小于限制，可以返回 data URL")]),a._v(" "),s("li",[a._v("图片，字体都可以使用file-loader, url-loader来处理")])])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("      {\n        test: '/\\.(png|jpg|jpeg|gif)$/',\n        use: {\n          loader: 'url-loader',\n          options: {\n            name: '[hash:7].[ext]',\n            outputPath: 'images/',\n            limit: 10240 \n            // 10kb 图片大小小于limit值，会将图片以base64的格式直接打包到JS中，\n            // 大于limit的值，则会直接将图片打包到dist目录\n          }\n        }\n      }\n")])])]),s("ul",[s("li",[a._v("样式资源")])]),a._v(" "),s("ol",[s("li",[a._v("css-loader")])]),a._v(" "),s("ul",[s("li",[a._v("解析CSS文件后，使用import加载，并且返回CSS代码,")]),a._v(" "),s("li",[a._v("会分析项目中几个css文件之间的依赖关系，最终将他们合并成一个css文件")]),a._v(" "),s("li",[a._v("options参数\nimportLoaders: 对于使用@import引入的样式文件，也执行css-loader前面的几个loaders")])]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("style-loader")])]),a._v(" "),s("ul",[s("li",[a._v("将模块的导出作为样式添加到DOM中")]),a._v(" "),s("li",[a._v("将css-loader处理生成的css文件挂载到页面中的head中")])]),a._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[a._v("sass-loader")])]),a._v(" "),s("ul",[s("li",[a._v("node-sass是sass-loader的依赖模块")]),a._v(" "),s("li",[a._v("将scss文件加载和转译为css文件")])]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("postcss-loader")])]),a._v(" "),s("ul",[s("li",[a._v("为css样式自动添加浏览器厂商前缀，还需要autoprefixer插件配合 ?? 配置失效")]),a._v(" "),s("li",[a._v("字体文件（eot|ttf|svg）\n"),s("ul",[s("li",[a._v("file-loader， 将字体文件直接从src目录移至dist目录即可")])])])]),a._v(" "),s("h3",{attrs:{id:"css分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css分离"}},[a._v("#")]),a._v(" CSS分离")]),a._v(" "),s("ul",[s("li",[a._v("extract-text-webpack-plugin")]),a._v(" "),s("li",[a._v("它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('const ExtractTextPlugin = require("extract-text-webpack-plugin");\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ExtractTextPlugin.extract({\n          fallback: "style-loader",\n          use: "css-loader"\n        })\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin("styles.css"),\n  ]\n}\n')])])]),s("h3",{attrs:{id:"css模块化-css-module"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css模块化-css-module"}},[a._v("#")]),a._v(" CSS模块化 (CSS MODULE) ??")]),a._v(" "),s("ul",[s("li",[a._v("解决CSS全局作用域问题，样式冲突(污染)问题")])]),a._v(" "),s("h2",{attrs:{id:"plugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[a._v("#")]),a._v(" plugin")]),a._v(" "),s("ul",[s("li",[a._v("plugin 可以在webpack运行到某个时刻的时候，帮你做一些事情，类似vue,react的生命周期函数")]),a._v(" "),s("li",[a._v("使用： 1）引入插件，2）在plugins数组中实例化插件，并且可以传入参数")])]),a._v(" "),s("h3",{attrs:{id:"htmlwebpackplugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#htmlwebpackplugin"}},[a._v("#")]),a._v(" HtmlWebpackPlugin")]),a._v(" "),s("ul",[s("li",[a._v("HtmlWebpackPlugin插件\n"),s("ul",[s("li",[a._v("会在打包结束后，在dist目录自动生成引用打包后的index.html文件")]),a._v(" "),s("li",[a._v("会在打包结束后，自动在dist文件夹生成一个html文件，并把打包生成的结果自动注入到这个html文件中")])])])]),a._v(" "),s("h3",{attrs:{id:"cleanwebpackplugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cleanwebpackplugin"}},[a._v("#")]),a._v(" CleanWebpackPlugin")]),a._v(" "),s("ul",[s("li",[a._v("CleanWebpackPlugin插件\n"),s("ul",[s("li",[a._v("会在打包开始前，删掉dist目录下的所有文件，避免上一次打包的影响")])])])])])}),[],!1,null,null,null);t.default=l.exports}}]);