(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{452:function(e,a,s){"use strict";s.r(a);var n=s(44),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"jsbridge的基本原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge的基本原理"}},[e._v("#")]),e._v(" JSBridge的基本原理")]),e._v(" "),s("ul",[s("li",[e._v("https://juejin.im/post/6844903904002457614")])]),e._v(" "),s("h3",{attrs:{id:"h5调用native的本质就是请求拦截"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#h5调用native的本质就是请求拦截"}},[e._v("#")]),e._v(" H5调用Native的本质就是请求拦截")]),e._v(" "),s("ul",[s("li",[e._v("在典型的JSBridge实现方案中，关于参数的处理是这样实现的：\n"),s("ul",[s("li",[e._v("首先，任何时候，H5中JS需要调用Native时，发送请求的url是固定不变的，比如gap://ready")]),e._v(" "),s("li",[e._v("其次，在window上定义一个全局的数组变量，名叫messageQueue，初始化时为空，当H5需要给Native发送消息时，先创建一个对象，并把所有相关的参数放在这个对象中，然后将这个对象插入messageQueue数组队尾")]),e._v(" "),s("li",[e._v("当native收到gap://ready的请求后，就知道H5有新消息，就会执行一段神奇的代码，进入到WebView中，并将定义在window上的全局变量messageQueue数组中全部数据打包取走，并将messageQueue清空，取走后逐条解析执行。我们用eval函数来充当这段神奇的代码来解释这里的逻辑")])])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("execIframe = document.createElement('iframe')\nexecIframe.style.display = 'none'\nexecIframe.src = 'gap://ready'\ndocument.body.appendChild(execIframe)\n\nconst messageQueue = []\nwindow.messageQueue = messageQue\nmessageQueue.push(JSON.stringify({\n  message: 'xxxx',\n  params: 'xxxx'\n}))\n\n//当Native拦截到'gap://ready'请求后执行的magic code\nconst messageQueue = eval('window.messageQueue')\nconst messages = JSON.parse(messageQueue)\nfor(let msg of messages){\n\n}\neval('window.messageQueue=[]')\n")])])]),s("h3",{attrs:{id:"native如何将处理结果告诉h5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#native如何将处理结果告诉h5"}},[e._v("#")]),e._v(" Native如何将处理结果告诉H5")]),e._v(" "),s("ul",[s("li",[e._v("如果H5需要Native执行完某一条指令时通知到H5，那么H5只需要在window上准备一个回调函数，在里面做该做的事，并将这个回调函数的名字在上一步创建消息对象时，放进这个对象中：")]),e._v(" "),s("li",[e._v("这样，在Native执行完你需要的指令后会再次执行那段神奇的代码进入WebView的世界，执行定义在window上名为callbackName的方法，并把native执行的结果传给这个方法")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("messageQueue.push(JSON.stringify({\n  message: 'xxx',\n  params: 'xxx',\n  callbackName: 'xxx'\n}))\n\nfor(let msg of messages){\n  let result = doSthWithMessage(message)\n  eval(`window[${message.callbackName}](${result})`)\n}\neval('window.messageQueue=[]')\n")])])]),s("ul",[s("li",[e._v("这也就揭露了Native是如何给H5发送消息的，直接执行window上定义好的一个方法即可")])]),e._v(" "),s("h3",{attrs:{id:"为了代码更规范-保证h5不胡乱的创建callbackname"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为了代码更规范-保证h5不胡乱的创建callbackname"}},[e._v("#")]),e._v(" 为了代码更规范，保证H5不胡乱的创建callBackName")]),e._v(" "),s("ul",[s("li",[e._v("为了代码更规范，保证H5不胡乱的创建callBackName，Native并不是直接执行window上的callbackName方法，而是会调用一个大概叫handleMessageFromNative的方法，这个方法是H5这边提前准备并定义在window上的方法，在这个方法中对消息的处理进行了收口，在里面调用window上的callbackName方法，执行完成后，将callbackName方法从window上删除掉")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//H5\nfunction handleMsgFromNative(message){\n  const {callback, result} = message\n  window.[callbackName](result)\n  delete window[callbackName]\n}\n\nwindow.handleMsgFromNative = handleMsgFromNative\n\n//Native\n\n")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);