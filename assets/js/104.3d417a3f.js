(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{463:function(t,_,v){"use strict";v.r(_);var e=v(44),l=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"渲染机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染机制"}},[t._v("#")]),t._v(" 渲染机制")]),t._v(" "),v("ul",[v("li",[t._v("浏览器渲染基本原理解析 https://mp.weixin.qq.com/s/njwpsI-5T2mewPYjNef0jA")]),t._v(" "),v("li",[t._v("浏览器渲染机制 https://www.jianshu.com/p/4bc1a46d7e9a")])]),t._v(" "),v("h3",{attrs:{id:"_1-什么是doctype及作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是doctype及作用"}},[t._v("#")]),t._v(" 1. 什么是DOCTYPE及作用")]),t._v(" "),v("ul",[v("li",[t._v("DTD（document type define，文档类型定义）是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式")]),t._v(" "),v("li",[t._v("DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错")]),t._v(" "),v("li",[t._v("常见的DOCTYPE类型有哪些：\n"),v("ul",[v("li",[t._v("HTML5 <!DOCTYPE html>")]),t._v(" "),v("li",[t._v("HTML4.01 有严格模式和传统模式")])])])]),t._v(" "),v("h3",{attrs:{id:"_2-浏览器渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器渲染过程"}},[t._v("#")]),t._v(" 2. 浏览器渲染过程")]),t._v(" "),v("ul",[v("li",[v("ol",[v("li",[t._v("从输入url到得到html的详细过程")])]),t._v(" "),v("ul",[v("li",[t._v("1）浏览器根据DNS服务器得到域名（url）的IP地址。")]),t._v(" "),v("li",[t._v("2）向这个IP的机器发送http（https）请求。")]),t._v(" "),v("li",[t._v("3）服务器收到、处理并返回http（https）请求。")]),t._v(" "),v("li",[t._v("4）浏览器得到返回的内容。")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[t._v("浏览器渲染页面的过程（得到返回内容之后怎么渲染成页面的过程")])]),t._v(" "),v("ul",[v("li",[t._v("1）解析HTML，生成DOM树（DOM）。")]),t._v(" "),v("li",[t._v("2）解析CSS，生成CSSOM树（CSSOM）")]),t._v(" "),v("li",[t._v("3）将DOM和CSSOM合并，生成渲染树（Render-Tree）。")]),t._v(" "),v("li",[t._v("4）计算渲染树的布局（Layout）")]),t._v(" "),v("li",[t._v("5）将布局渲染到屏幕上（Paint）")])])])]),t._v(" "),v("h3",{attrs:{id:"_3-几个关键概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-几个关键概念"}},[t._v("#")]),t._v(" 3.几个关键概念")]),t._v(" "),v("h4",{attrs:{id:"_1-css阻塞渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-css阻塞渲染"}},[t._v("#")]),t._v(" 1)CSS阻塞渲染：")]),t._v(" "),v("ul",[v("li",[t._v("由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染。CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在head中，仅仅是为了更快的解析CSS，保证更快的首次渲染。")])]),t._v(" "),v("h4",{attrs:{id:"_2-js阻塞页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-js阻塞页面"}},[t._v("#")]),t._v(" 2)JS阻塞页面：")]),t._v(" "),v("ul",[v("li",[t._v("JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在解析HTML时，一旦碰到script，就会立即停止HTML的解析，也阻塞了其后的CSS解析，整个解析进程必须等待JS的执行完成才能够继续。从性能角度上讲，将script放在页面底部，也就合情合理了")])]),t._v(" "),v("h4",{attrs:{id:"_3-重排-reflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-重排-reflow"}},[t._v("#")]),t._v(" 3)重排（Reflow）：")]),t._v(" "),v("ul",[v("li",[t._v("DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算, 并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow")]),t._v(" "),v("li",[t._v("触发重排（reflow）：\n"),v("ul",[v("li",[t._v("1、当增加、删除、修改DOM节点时，会导致reflow或repaint")]),t._v(" "),v("li",[t._v("2、当移动DOM的位置，或是插入动画的时候")]),t._v(" "),v("li",[t._v("3、当修改CSS样式的时候")]),t._v(" "),v("li",[t._v("4、当Resize窗口的时候，或是滚动的时候")]),t._v(" "),v("li",[t._v("5、当修改网页的默认字体时\n当网页Repaint完的时候最好不要修改默认字体，会非常耗性能。（把样式放到head里面）")])])])]),t._v(" "),v("h4",{attrs:{id:"_4-重绘-repaint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-重绘-repaint"}},[t._v("#")]),t._v(" 4)重绘（Repaint）：")]),t._v(" "),v("ul",[v("li",[t._v("当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。")]),t._v(" "),v("li",[t._v("触发重绘（Repaint）：\n"),v("ul",[v("li",[t._v("1、DOM改动（代码片段）")]),t._v(" "),v("li",[t._v("2、CSS改动")])])]),t._v(" "),v("li",[t._v("最小化重绘和重排\n"),v("ul",[v("li",[t._v("1.一次性修改样式：减少内联样式使用 样式合并写法")]),t._v(" "),v("li",[t._v("2.批量修改DOM：使用文档片段创建一个子树，然后再拷贝到文档中（document.fragment）")]),t._v(" "),v("li",[t._v("3.缓存布局信息")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//每次需要查询div.offsetLeft 浪费性能\ndiv.style.left = 1 + div.offsetLeft + 'px';\ndiv.style.top = 1 + div.offsetTop + 'px';\n\n//将这个值保存下来，避免重复取值 性能优化\ncurrent = div.offsetLeft;\ndiv.style.left = 1 + ++current + 'px';\ndiv.style.top = 1 + ++current + 'px';\n")])])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);