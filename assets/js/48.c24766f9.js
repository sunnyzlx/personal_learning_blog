(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{406:function(r,a,t){"use strict";t.r(a);var n=t(44),e=Object(n.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"js算法思想学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js算法思想学习"}},[r._v("#")]),r._v(" js算法思想学习")]),r._v(" "),t("ul",[t("li",[r._v("算法的本质是寻找规律并实现")]),r._v(" "),t("li",[r._v("如何找到规律？发现输入和输出的关系，找到突破点")]),r._v(" "),t("li",[r._v("复杂的实现怎么办？ 实现是程序加数据结构的结合体")]),r._v(" "),t("li",[r._v("数据结构用来保存数据和调度，本身一个代码的实现靠的是程序结构和数据结构的配合")])]),r._v(" "),t("h2",{attrs:{id:"基础算法-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础算法-5"}},[r._v("#")]),r._v(" 基础算法（5）")]),r._v(" "),t("h3",{attrs:{id:"字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[r._v("#")]),r._v(" 字符串")]),r._v(" "),t("h4",{attrs:{id:"反转字符串中的单词"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反转字符串中的单词"}},[r._v("#")]),r._v(" 反转字符串中的单词")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("// reverse()方法是数组方法，故需要先将item.split('')由字符串变为数组\n  export function reverseWord(str){\n    return str.split(' ').map(item => {\n      return item.split('').reverse().join('')\n    }).join(' ')\n  }\n  // split分割 匹配正则，\\s空格， g全局匹配，查找所有匹配，而非在找到第一个匹配后停止\n  export function reverseWord1(str){\n    return str.split(/\\s/g).map(item => {\n      return item.split('').reverse().join('')\n    }).join(' ')\n  }\n\n  // match识别 匹配正则，[]可选项，\\w匹配大写字母小写字母0-9_，+多余1次， g全局匹配，查找所有匹配，而非在找到第一个匹配后停止\n  export function reverseWord2(str){\n    return str.match(/[\\w']+/g).map(item => {\n      return item.split('').reverse().join('')\n    }).join(' ')\n  }\n")])])]),t("h4",{attrs:{id:"计算二进制字串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算二进制字串"}},[r._v("#")]),r._v(" 计算二进制字串")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("function a(s) {\n      let r = [];\n      let match = (str) => {\n        let j = str.match(/^(0+|1+)/)[0]\n        let o = (j[0] ^ 1).toString().repeat(j.length)\n        let reg = new RegExp(`^(${j}${o})`)\n        if (reg.test(str)) {\n          return RegExp.$1\n        } else {\n          return ''\n        }\n      }\n      for (let i = 0; i < s.length - 1; i++) {\n        let sub = match(s.slice(i))\n        if (sub) {\n          r.push(sub)\n        }\n      }\n      console.log(r)\n    };\n")])])]),t("h3",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[r._v("#")]),r._v(" 数组")]),r._v(" "),t("h4",{attrs:{id:"电话号码的组合-公式运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#电话号码的组合-公式运算"}},[r._v("#")]),r._v(" 电话号码的组合（公式运算）")]),r._v(" "),t("h4",{attrs:{id:"卡牌分组-归类运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卡牌分组-归类运算"}},[r._v("#")]),r._v(" 卡牌分组（归类运算）")]),r._v(" "),t("h4",{attrs:{id:"种花问题-筛选运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#种花问题-筛选运算"}},[r._v("#")]),r._v(" 种花问题（筛选运算）")]),r._v(" "),t("h4",{attrs:{id:"格雷编码-编码运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#格雷编码-编码运算"}},[r._v("#")]),r._v(" 格雷编码（编码运算）")]),r._v(" "),t("h3",{attrs:{id:"正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[r._v("#")]),r._v(" 正则表达式")]),r._v(" "),t("h4",{attrs:{id:"重复的子字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重复的子字符串"}},[r._v("#")]),r._v(" 重复的子字符串")]),r._v(" "),t("h4",{attrs:{id:"正则表达式匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式匹配"}},[r._v("#")]),r._v(" 正则表达式匹配")]),r._v(" "),t("h3",{attrs:{id:"排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[r._v("#")]),r._v(" 排序 *****")]),r._v(" "),t("ul",[t("li",[r._v("时间复杂度： 看得是运行次数， 空间复杂度： 看得是占用内存情况")]),r._v(" "),t("li",[r._v("参考连接：https://www.jianshu.com/p/f4cca5ce055a")])]),r._v(" "),t("h4",{attrs:{id:"快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[r._v("#")]),r._v(" 快速排序")]),r._v(" "),t("h4",{attrs:{id:"冒泡排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[r._v("#")]),r._v(" 冒泡排序")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("// 原理： 相邻两两比较，然后换位置\nfunction bubbleSort(arr){\n  for(let i=arr.length-1, temp; i>0; i--){ //定义每次循环的遍历次数，即边界\n    for(let j=0; j<i; j++){ //定义从当前位置遍历到哪个边界\n      if(arr[j]>arr[j+1]){ //比较大小\n        temp=arr[j] //暂存当前元素\n        arr[j]=arr[j+1] //交换位置，冒泡输出元素\n        arr[j+1]=temp\n      }\n    }\n  }\n  return arr\n}\n")])])]),t("h4",{attrs:{id:"选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[r._v("#")]),r._v(" 选择排序")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("// 原理：从当前元素开始，选择比ta小的元素，跟ta交换位置\nfunction selectionSort(arr){\n  for(var i=0, len=arr.length, min; i<len;i++){ //确定每次循环的循环边界\n    min=arr[i] //暂存当前元素\n    for(var j=i+1;j<len;j++){ //从循环边界开始遍历到最后，找出比当前元素小的元素\n      if(arr[j]<min){ \n        var c = min\n        min=arr[j]\n        arr[j]=c\n      }\n    }\n    arr[i]=min //将找出的最小值赋值给当前元素\n  }\n  return arr\n}\n\n  export function selectSort(arr){\n    for(let i = 0, len = arr.length,tmp; i< len; i++){\n      for(let j = i+1; j < len; j++){\n        if(arr[i]<arr[j]){\n          tmp = arr[i]\n          arr[i] = arr[j]\n          arr[j] = tmp\n        }\n      }\n    }\n    return arr\n  }\n")])])]),t("h4",{attrs:{id:"希尔排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序"}},[r._v("#")]),r._v(" 希尔排序")]),r._v(" "),t("h4",{attrs:{id:"按奇偶排序数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按奇偶排序数组"}},[r._v("#")]),r._v(" 按奇偶排序数组")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("export function oddSort(arr){\n    // 进行升序排序\n    arr.sort((a,b)=>a-b)\n    // 声明一个空数组来存储奇偶排序后的数组\n    let r=[]\n    // 记录奇数和偶数位下标\n    let odd=1\n    let even=0\n    arr.forEach(item=>{\n      if(item%2===1){\n        r[odd]=item\n        odd+=2\n      }else{\n        r[even]=item\n        even+=2\n      }\n    })\n    return r\n  }\n")])])]),t("h4",{attrs:{id:"数组中的第k个最大元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组中的第k个最大元素"}},[r._v("#")]),r._v(" 数组中的第k个最大元素")]),r._v(" "),t("ul",[t("li",[r._v("思路：1）排序 2）遍历")])]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("  // 代码量少，但性能较差，需要循环遍历整个数组\n  export function sort(arr, k){\n    return arr.sort((a, b)=>b-a)[k-1]\n  }\n  // 性能较好，借助冒泡原理，只需遍历k次，降序排\n  export function sort1(arr, k){\n    let len = arr.lenth-1\n    for(let i = len, tmp; i > len-k; i--){\n      for(let j = 0; j < i; j++){\n        if(arr[j]<arr[j+1]){\n          tmp = arr[j]\n          arr[j] = arr[j+1]\n          arr[j+1] = tmp\n        }\n      }\n    }\n    return arr[k-1]\n  }\n  // 性能较好，借助冒泡原理，只需遍历k次，升序排\n  export function sort2(arr, k){\n    let len = arr.length-1\n    for(let i = len, tmp; i < len-k; i--){\n      for(let j = 0; j < i; j++){\n        if(arr[j]>arr[j+1]){\n          tmp = arr[j]\n          arr[j] = arr[j+1]\n          arr[j+1] = tmp\n        }\n      }\n    }\n    // return arr[len-k+1]\n    return arr[len-(k-1)]\n  }\n")])])]),t("h4",{attrs:{id:"最大间距"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最大间距"}},[r._v("#")]),r._v(" 最大间距")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("// 法一：常规解法，性能不高，sort()方法遍历一次，寻找差值时又遍历一次\nfunction maxSpace(arr){\n  // 如果数组长度小于2返回0\n  if(arr.length<2){\n    return 0\n  }\n  // 排序\n  arr.sort()\n  // 暂存相邻元素的最大差值\n  var max = 0\n  for(var i=0, len=arr.lenth-1, tmp; i<len; i++){ //当前元素与下一元素比较\n    tmp = arr[i+1]-arr[i]  //tmp暂存相邻两元素间差值\n    if(tmp>max){\n      max=tmp\n    }\n  }\n  return max\n}\n// 法二：\nfunction maxinumGap(arr){\n  if(arr.length<2){\n    return 0\n  }\n  let max = 0\n  let len = arr.lenth-1\n  let space\n  for(let i=len, tmp; i>0; i--){\n    for(let j=0; j<i; j++){\n      tmp = arr[j]\n      if(tmp<arr[j+1]){\n        arr[j] = arr[j+1]\n        arr[j+1] = tmp\n      }\n    }\n    if(i<len){\n      space= arr[i+1]-arr[i]\n      if(space>max){\n        max = space\n      }\n    }\n  }\n  return Math.max(max, arr[1]-arr[0])\n}\n")])])]),t("h4",{attrs:{id:"缺失的第一个正数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺失的第一个正数"}},[r._v("#")]),r._v(" 缺失的第一个正数")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("// 法一： sort()排序一次，for循环一次，性能较差\nexport function firstw(arr){\n    // 过滤掉非正整数\n    arr = arr.filter(item => item>0)\n    // 正整数数组是不是为空\n    if(arr.length){\n      // 升序排序，方便从左往右取最小值arr[0]\n      arr.sort((a, b) => a-b)\n      // 如果第一个元素不为1，返回1\n      if(arr[0]!==1){\n        return 1\n      }else{\n        // 从左边开始遍历，只要下一个元素与当前元素的差值>1,则返回当前元素+1\n        for(let i=0,len=arr.length; i<len; i++){\n          if(arr[i+1]-arr[i]>1){\n            return arr[i]+1\n          }\n        }\n        // 如果数组是连续的正整数，则返回最后一个元素+1\n        return arr.pop()+ 1\n      }\n    }else{\n      return 1\n    }\n  }\n// 法二： filter过滤不能省，利用选择排序依次拿到最小值，减少循环遍历次数，提高性能\n  export function firstw1(arr){\n    arr = arr.filter(item => item>0)\n    console.log(arr.length)\n    // 实现选择排序，先拿到最小值，如果第一个元素不是1直接返回1，如果是1，就要比相邻元素差值\n    for(let i=0,len=arr.length,tmp; i<len; i++){\n      for(let j=i+1; j<len; j++){\n        if(arr[i]>arr[j]){\n          tmp = arr[i]\n          arr[i] = arr[j]\n          arr[j] = tmp\n        }\n      }\n      if(i>0){\n        if(arr[i]-arr[i-1]>1){\n          return arr[i-1]+1\n        }\n      }else{\n        if(arr[0]!==1){\n          return 1\n        }\n      }\n    }\n    return arr.length? arr.pop()+1: 1   \n  }\n")])])]),t("h3",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[r._v("#")]),r._v(" 递归 *****")]),r._v(" "),t("ul",[t("li",[r._v("本质：每一个处理过程都是相同的，输入和输出是相同的，处理次数未知")])]),r._v(" "),t("h4",{attrs:{id:"复原ip地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复原ip地址"}},[r._v("#")]),r._v(" 复原IP地址")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("export default (str) => {\n  //保存所有符合条件的ip\n  let r = [];\n  //递归函数\n  let search = (cur, sub) => {\n    if(cur.length === 4 && cur.join('') === str){\n      r.push(cur.join('.'))\n    }else{\n      for(let i=0,len=Math.min(3, sub.length),tmp; i<len;i++){\n        tmp= sub.substr(0, i+1);\n        if(tmp>=0 && tmp<256){\n          search(cur.concat([tmp]),sub.substr(i+1))\n        }\n      }\n    }\n  }\n  search([], str);\n  return r;\n}\n")])])]),t("h4",{attrs:{id:"与所有单词相关联的字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#与所有单词相关联的字符串"}},[r._v("#")]),r._v(" 与所有单词相关联的字符串")]),r._v(" "),t("h2",{attrs:{id:"数据结构-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-6"}},[r._v("#")]),r._v(" 数据结构（6）")]),r._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[r._v("#")]),r._v(" 堆 ****")]),r._v(" "),t("h4",{attrs:{id:"根据字符出现频率排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据字符出现频率排序"}},[r._v("#")]),r._v(" 根据字符出现频率排序")]),r._v(" "),t("h4",{attrs:{id:"超级丑数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#超级丑数"}},[r._v("#")]),r._v(" 超级丑数")]),r._v(" "),t("h3",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[r._v("#")]),r._v(" 栈 ****")]),r._v(" "),t("h4",{attrs:{id:"棒球比赛"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#棒球比赛"}},[r._v("#")]),r._v(" 棒球比赛")]),r._v(" "),t("h4",{attrs:{id:"最大矩形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最大矩形"}},[r._v("#")]),r._v(" 最大矩形")]),r._v(" "),t("h3",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[r._v("#")]),r._v(" 队列 ****")]),r._v(" "),t("h4",{attrs:{id:"设计循环队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计循环队列"}},[r._v("#")]),r._v(" 设计循环队列")]),r._v(" "),t("h4",{attrs:{id:"任务调度器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务调度器"}},[r._v("#")]),r._v(" 任务调度器")]),r._v(" "),t("h2",{attrs:{id:"算法进阶-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法进阶-2"}},[r._v("#")]),r._v(" 算法进阶（2）")]),r._v(" "),t("h3",{attrs:{id:"贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[r._v("#")]),r._v(" 贪心算法")]),r._v(" "),t("h4",{attrs:{id:"买卖股票的最佳时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#买卖股票的最佳时机"}},[r._v("#")]),r._v(" 买卖股票的最佳时机")]),r._v(" "),t("h4",{attrs:{id:"柠檬水找零"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柠檬水找零"}},[r._v("#")]),r._v(" 柠檬水找零")]),r._v(" "),t("h3",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[r._v("#")]),r._v(" 动态规划")]),r._v(" "),t("h4",{attrs:{id:"不同路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同路径"}},[r._v("#")]),r._v(" 不同路径")]),r._v(" "),t("h4",{attrs:{id:"k站中转内最便宜的航班"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k站中转内最便宜的航班"}},[r._v("#")]),r._v(" k站中转内最便宜的航班")]),r._v(" "),t("h4",{attrs:{id:"js手写map-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js手写map-方法"}},[r._v("#")]),r._v(" js手写map(方法)")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("Array.prototype.newMap = function(fn, context){\n  let arr = this;\n  let result = [];\n  for(let i=0; i<arr.length; i++){\n    result.push(fn.call(context, arr[i], i, arr))\n  }\n  return result;\n}\n")])])]),t("h4",{attrs:{id:"求取a-b的最大公约数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#求取a-b的最大公约数"}},[r._v("#")]),r._v(" 求取a,b的最大公约数")]),r._v(" "),t("p",[r._v("export default function gcd(a,b){\nif(b===0){\nreturn a;\n}else{\nreturn gcd(b, a%b)\n}\n}")])])}),[],!1,null,null,null);a.default=e.exports}}]);