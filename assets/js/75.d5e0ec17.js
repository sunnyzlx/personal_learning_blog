(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{433:function(e,t,v){"use strict";v.r(t);var a=v(44),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue基础"}},[e._v("#")]),e._v(" vue基础")]),e._v(" "),v("h2",{attrs:{id:"使用jquery和vue框架的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用jquery和vue框架的区别"}},[e._v("#")]),e._v(" 使用jquery和vue框架的区别")]),e._v(" "),v("ul",[v("li",[e._v("数据和视图的分离，解藕（开放封闭原则）")]),e._v(" "),v("li",[e._v("以数据驱动视图，只关心数据变化， DOM操作被封装")])]),e._v(" "),v("h2",{attrs:{id:"说一下对mvvm的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说一下对mvvm的理解"}},[e._v("#")]),e._v(" 说一下对MVVM的理解")]),e._v(" "),v("ul",[v("li",[e._v("mvc基本介绍\n"),v("ul",[v("li",[e._v("view： view视图 界面")]),e._v(" "),v("li",[e._v("model：数据模型")]),e._v(" "),v("li",[e._v("control：控制器（逻辑处理）")])])]),e._v(" "),v("li",[e._v("mvvm基本介绍\n"),v("ul",[v("li",[e._v("View：视图 模版（视图和模型是分离的）\n"),v("ul",[v("li",[e._v("通过事件绑定影响model")])])]),e._v(" "),v("li",[e._v("Model：模型，数据\n"),v("ul",[v("li",[e._v("通过事件绑定影响model")])])]),e._v(" "),v("li",[e._v("ViewModel：连接Model和View（连接器）")]),e._v(" "),v("li",[e._v("所谓双向数据绑定，即数据变化更新视图，视图变化更新数据")])])])]),e._v(" "),v("h2",{attrs:{id:"vue的三要素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的三要素"}},[e._v("#")]),e._v(" vue的三要素")]),e._v(" "),v("ul",[v("li",[e._v("响应式： vue如何监听到data的每个属性变化")]),e._v(" "),v("li",[e._v("模版引擎： vue的模版如何被解析，指令如何处理")]),e._v(" "),v("li",[e._v("渲染：vue的模版如何被渲染成html，以及渲染过程")])]),e._v(" "),v("h2",{attrs:{id:"什么是响应式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是响应式"}},[e._v("#")]),e._v(" 什么是响应式")]),e._v(" "),v("ul",[v("li",[e._v("修改data属性之后，vue立刻监听到")]),e._v(" "),v("li",[e._v("data属性被代理到vm上")]),e._v(" "),v("li",[e._v("object.defineProperty模拟实现（响应式模拟）")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    var vm= {}\n    var data = {\n        name: 'zhangsan',\n        age: 'lisi'\n    }\n    \n    var key，  value\n    for（key in value）{\n        function(key){\n            Object.defineProperty(vm, key, {\n                get: function(){\n                    console.log('get', data[key])   //监听\n                    return data[key]\n                }\n                set: function(newVal){\n                    console.log('set', newVal)   //监听\n                    data[key] = newVal\n                }\n            }){\n                \n            }\n        }(key)\n    }\n")])])]),v("h2",{attrs:{id:"vue中如何解析模版"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中如何解析模版"}},[e._v("#")]),e._v(" vue中如何解析模版")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("模版是什么")]),e._v(" "),v("ul",[v("li",[e._v("本质是字符串")]),e._v(" "),v("li",[e._v("有逻辑，v-if  v-for等")]),e._v(" "),v("li",[e._v("与html格式很像，但有很大区别，html是静态的，vue是动态的")]),e._v(" "),v("li",[e._v("最终还是要转化为html来展示")]),e._v(" "),v("li"),e._v(" "),v("li",[e._v("模版最终要转换为js代码原因：\n"),v("ul",[v("li",[e._v("有逻辑 v-if，v-for，必须用js才能实现（图灵完备）")]),e._v(" "),v("li",[e._v("转换为html渲染页面，必须由js实现")]),e._v(" "),v("li",[e._v("因此模版最终要转换为一个js函数（render函数）")])])])])]),e._v(" "),v("li",[v("p",[e._v("render函数")])]),e._v(" "),v("li",[v("p",[e._v("vdom")])])]),e._v(" "),v("h2",{attrs:{id:"vue的整个实现流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的整个实现流程"}},[e._v("#")]),e._v(" vue的整个实现流程")]),e._v(" "),v("ul",[v("li",[e._v("解析模版成render函数\n"),v("ul",[v("li",[e._v("width的用法")]),e._v(" "),v("li",[e._v("模版中的所有信息都被render函数包含")]),e._v(" "),v("li",[e._v("模版中用到的data的属性，全都变成js变量")]),e._v(" "),v("li",[e._v("模版中的v-if v-for  v-on，全部都变成了js逻辑")]),e._v(" "),v("li",[e._v("render函数返回vnode")])])]),e._v(" "),v("li",[e._v("响应式开始监听")]),e._v(" "),v("li",[e._v("object.defineProperty")]),e._v(" "),v("li",[e._v("将data的属性代理到vm上")]),e._v(" "),v("li",[e._v("首次渲染，显示页面，且绑定依赖")]),e._v(" "),v("li",[e._v("data属性变化，触发rerender")])]),e._v(" "),v("h2",{attrs:{id:"vue双向数据绑定原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue双向数据绑定原理"}},[e._v("#")]),e._v(" vue双向数据绑定原理")]),e._v(" "),v("ul",[v("li",[e._v("vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")])]),e._v(" "),v("h2",{attrs:{id:"vue组件间的参数传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件间的参数传递"}},[e._v("#")]),e._v(" vue组件间的参数传递")]),e._v(" "),v("h2",{attrs:{id:"vue的路由实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的路由实现"}},[e._v("#")]),e._v(" vue的路由实现")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("hash ——即地址栏URL中的#符号。比如这个URL：http://www.abc.com/#/hello, hash 的值为#/hello。它的特点在于：hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。")])]),e._v(" "),v("li",[v("p",[e._v("history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法。（需要特定浏览器支持）            这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。          history模式，会出现404 的情况，需要后台配置。")])]),e._v(" "),v("li",[v("p",[e._v("404 错误")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("hash模式下，仅hash符号之前的内容会被包含在请求中，如 http://www.abc.com, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误；")])]),e._v(" "),v("li",[v("p",[e._v("history模式下，前端的url必须和实际向后端发起请求的url 一致，如http://www.abc.com/book/id 。如果后端缺少对/book/id 的路由处理，将返回404错误。")])])])])]),e._v(" "),v("h2",{attrs:{id:"vue路由传参的三种方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue路由传参的三种方法"}},[e._v("#")]),e._v(" vue路由传参的三种方法")]),e._v(" "),v("ul",[v("li",[e._v("直接在路由中写参数")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<li v-for=\"article in articles\" @click=\"getDescribe(article.id)\">\n getDescribe(id) {\n//   直接调用$router.push 实现携带参数的跳转\n        this.$router.push({\n          path: `/describe/${id}`,\n })\n//在router---\x3eindex.js进行配置\n {\n     path: '/describe/:id',\n     name: 'Describe',\n     component: Describe\n   }\n\n\n//通过this.$route.prams.id取值\n")])])]),v("ul",[v("li",[e._v("通过prams传参")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("this.$router.push({\n          name: 'Describe',\n          params: {\n            id: id\n          }\n })\n//在router---\x3eindex.js进行配置\n{\n     path: '/describe',\n     name: 'Describe',\n     component: Describe\n}\n//通过this.$route.prams.id取值\n")])])]),v("ul",[v("li",[e._v("通过query传参")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("this.$router.push({\n          path: '/describe',\n          query: {\n            id: id\n  }\n//在router---\x3eindex.js进行配置\n{\n     path: '/describe',\n     name: 'Describe',\n     component: Describe\n }\n//通过this.$route.query.id取值\n")])])]),v("h2",{attrs:{id:"vue的路由钩子函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的路由钩子函数"}},[e._v("#")]),e._v(" vue的路由钩子函数")]),e._v(" "),v("h2",{attrs:{id:"vuex面试相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex面试相关"}},[e._v("#")]),e._v(" vuex面试相关")]),e._v(" "),v("ul",[v("li",[e._v("（1）vuex是什么？怎么使用？哪种功能场景使用它？")])]),e._v(" "),v("p",[e._v("vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")]),e._v(" "),v("ul",[v("li",[e._v("（2）vuex有哪几种属性？")])]),e._v(" "),v("p",[e._v("有五种，分别是 State、 Getter、Mutation 、Action、 Module")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("vuex的State特性")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data")])]),e._v(" "),v("li",[v("p",[e._v("B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新")])]),e._v(" "),v("li",[v("p",[e._v("C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")])])])]),e._v(" "),v("li",[v("p",[e._v("vuex的Getter特性")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("A、getters可以对State进行计算操作，它就是Store的计算属性")])]),e._v(" "),v("li",[v("p",[e._v("B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用")])]),e._v(" "),v("li",[v("p",[e._v("C、 如果一个状态只在一个组件内使用，是可以不用getters")])])])]),e._v(" "),v("li",[v("p",[e._v("vuex的Mutation特性")]),e._v(" "),v("ul",[v("li",[e._v("Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。")])])]),e._v(" "),v("li",[v("p",[e._v("（3）不用Vuex会带来什么问题？")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("可维护性会下降，想修改数据要维护三个地方；")])]),e._v(" "),v("li",[v("p",[e._v("可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；")])]),e._v(" "),v("li",[v("p",[e._v("增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。")])])])])]),e._v(" "),v("h2",{attrs:{id:"css只在当前组件起作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css只在当前组件起作用"}},[e._v("#")]),e._v(" css只在当前组件起作用？")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("   当前组件<style>写成<style  scoped> \n")])])]),v("h2",{attrs:{id:"v-if和v-show的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show的区别"}},[e._v("#")]),e._v(" v-if和v-show的区别？")]),e._v(" "),v("ul",[v("li",[e._v("v-if的显示和隐藏是在dom里创建和消除dom节点")]),e._v(" "),v("li",[e._v("v-show是用css样式的display来控制dom节点的显示和隐藏")])]),e._v(" "),v("h2",{attrs:{id:"route和-router的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#route和-router的区别"}},[e._v("#")]),e._v(" $route和$router的区别")]),e._v(" "),v("ul",[v("li",[e._v("在任何组件内通过 this.$router访问路由器，也可以通过 this.$route 访问当前路由")])]),e._v(" "),v("h2",{attrs:{id:"vue-js的两个核心是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-js的两个核心是什么"}},[e._v("#")]),e._v(" vue.js的两个核心是什么")]),e._v(" "),v("ul",[v("li",[e._v("数据驱动")]),e._v(" "),v("li",[e._v("组件系统")])]),e._v(" "),v("h2",{attrs:{id:"vue几种常用的指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue几种常用的指令"}},[e._v("#")]),e._v(" vue几种常用的指令")]),e._v(" "),v("ul",[v("li",[e._v("v-text v-html v-bind v-on v-model v-for")])]),e._v(" "),v("h2",{attrs:{id:"vue常用的修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue常用的修饰符"}},[e._v("#")]),e._v(" vue常用的修饰符")]),e._v(" "),v("h2",{attrs:{id:"v-on可以绑定多个方法吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-on可以绑定多个方法吗"}},[e._v("#")]),e._v(" v-on可以绑定多个方法吗")]),e._v(" "),v("ul",[v("li",[e._v("可以")])]),e._v(" "),v("h2",{attrs:{id:"vue中key值的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中key值的作用"}},[e._v("#")]),e._v(" vue中key值的作用！！！")]),e._v(" "),v("ul",[v("li",[e._v("需要提供一个唯一的key值（常用ID），以便它能跟踪每个节点的身份，从而重用和重新排序现有元素")])]),e._v(" "),v("h2",{attrs:{id:"什么是vue的计算属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是vue的计算属性"}},[e._v("#")]),e._v(" 什么是vue的计算属性")]),e._v(" "),v("h2",{attrs:{id:"vue等单页面应用及其优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue等单页面应用及其优缺点"}},[e._v("#")]),e._v(" vue等单页面应用及其优缺点")]),e._v(" "),v("ul",[v("li",[e._v("优点：")])]),e._v(" "),v("p",[e._v("Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。")]),e._v(" "),v("ul",[v("li",[e._v("缺点：")])]),e._v(" "),v("p",[e._v("不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。")]),e._v(" "),v("h2",{attrs:{id:"浏览器输入url到页面展示发生了些什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入url到页面展示发生了些什么"}},[e._v("#")]),e._v(" 浏览器输入url到页面展示发生了些什么")]),e._v(" "),v("h2",{attrs:{id:"性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[e._v("#")]),e._v(" 性能优化")])])}),[],!1,null,null,null);t.default=r.exports}}]);