(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{388:function(t,r,a){"use strict";a.r(r);var e=a(44),n=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"数组类高频面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组类高频面试题"}},[t._v("#")]),t._v(" 数组类高频面试题")]),t._v(" "),a("h2",{attrs:{id:"一-数组扁平化-5种解法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-数组扁平化-5种解法"}},[t._v("#")]),t._v(" 一.数组扁平化(5种解法)")]),t._v(" "),a("p",[a("strong",[t._v("拍平多维数组var arr = [1, 2, 3, [3, 3, 3, [5, 4, 5, 6, 6, 7, 8]],333, 4444]];")])]),t._v(" "),a("ul",[a("li",[t._v("递归处理")]),t._v(" "),a("li",[t._v("闭包+递归处理")]),t._v(" "),a("li",[t._v("es6扩展运算符+reduce/concat+push+reduce")]),t._v(" "),a("li",[t._v("toString处理")]),t._v(" "),a("li",[t._v("rest参数")])]),t._v(" "),a("h3",{attrs:{id:"_1-递归处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-递归处理"}},[t._v("#")]),t._v(" 1. 递归处理")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function flatten(arr){\n  let child = []; //child变量在每次递归时都会清空。故每次遍历结束都需要返回\n  for(let i of arr){\n    if(Array.isArray(i)){\n      child = [...child, ...flatten(i)] \n      //注意：flatten(i)之后的结果也需要展开，否则，只能复制数组，无法扁平化\n    }else{\n      child = [...child, i]\n    }\n  }\n  return child;\n}\nfunction flatten(arr){\n  let child = []\n  for(let item of arr){\n    if(Array.isArray(item)){  \n      child = child.concat(flatten(item))\n    }else{\n      child.push(item)\n    }\n  }\n  return child\n}\nconsole.log(flatten(arr))\n//  concat方法不会改变原数组，join会\n//  concat连接的不仅可以是具体的值，也可以是数组，当是数组时，添加的时数组中的值，该方法不改变原数组，而是返回一个连接后的副本，故使用concat,要把结果赋值给新变量\n//  push会改写原数组，并返回新数组的长度，故不需要新变量承接\n")])])]),a("h3",{attrs:{id:"_2-闭包-递归处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-闭包-递归处理"}},[t._v("#")]),t._v(" 2. 闭包+递归处理")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let product = () => {\n  let child = [] //闭包中的child变量会一直在内存中，是一个累积变量\n  let flatten = (arr) => {\n    for(let item of arr){\n      if(Array.isArray(item)){\n        flatten(item) //此处的作用只是判断item为数组，就将它推入下一次递归\n      }else{\n        child.push(item) \n        //push会改变原数组，并返回新数组的长度，所有的数组元素都是在此处被push进child变量\n      }\n    }\n    return child //每次都返回一个累积后的child变量\n  }\n  return flatten\n}\nlet f = product()\nconsole.log(f(arr2))\n")])])]),a("h3",{attrs:{id:"_3-es6扩展运算符-reduce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-es6扩展运算符-reduce"}},[t._v("#")]),t._v(" 3. es6扩展运算符+reduce")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function flatten(arr){\n  return arr.reduce((acc, cur)=>{\n    if(Array.isArray(cur)){\n      return [...acc, ...flatten(cur)]\n    }else{\n      return [...acc, cur]\n    }\n  }, [])\n}\nfunction flatten(arr){\n  return arr.reduce((acc,cur)=>{\n    return acc.concat(Array.isArray(cur) ? flatten(cur) : cur)\n  },[])\n}\n")])])]),a("h3",{attrs:{id:"_4-tostring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-tostring"}},[t._v("#")]),t._v(" 4. toString()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function flatten(arr){\n  return arr.toString().split(',').map(item=> +item)\n}\n// 数组的toString()方法将数组转化为其字符串形式, split方法将字符串用指定分隔符切成数组，+item将字符串转化为number类型\n//该方法无法处理数组成员为非数组的情况，最终会被转化为NaN\n")])])]),a("h3",{attrs:{id:"_5-rest参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-rest参数"}},[t._v("#")]),t._v(" 5. rest参数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function flatten(arr){\n  while(arr.some(item => Array.isArray(item))){\n    arr = [].concat(...arr)\n  }\n  return arr\n}\n")])])]),a("p",[t._v("// rest参数默认只能展开一层,扩展运算符不会修改原数组")]),t._v(" "),a("h2",{attrs:{id:"二-数组去重的7种姿势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-数组去重的7种姿势"}},[t._v("#")]),t._v(" 二.数组去重的7种姿势")]),t._v(" "),a("p",[a("strong",[t._v("数组去重var arr = [1,2,2,3,4,5,6,4]")])]),t._v(" "),a("ul",[a("li",[t._v("双重循环去重")]),t._v(" "),a("li",[t._v("filter+indexOf去重")]),t._v(" "),a("li",[t._v("forEach+includes去重")]),t._v(" "),a("li",[t._v("reduce+sort去重")]),t._v(" "),a("li",[t._v("对象键值对去重")]),t._v(" "),a("li",[t._v("Map去重")]),t._v(" "),a("li",[t._v("Set去重")])]),t._v(" "),a("h3",{attrs:{id:"最优的数组去重算法是采用map数据结构实现的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最优的数组去重算法是采用map数据结构实现的算法"}},[t._v("#")]),t._v(" 最优的数组去重算法是采用Map数据结构实现的算法")]),t._v(" "),a("h3",{attrs:{id:"_1-双重循环去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-双重循环去重"}},[t._v("#")]),t._v(" 1. 双重循环去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function unique(arr){\n  let len = arr.length;\n  for(let i=0; i<len;i++){\n    for(let j=i+1; j<len;j++){\n      if(arr[i]===arr[j]){\n        // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一\n        arr.splice(j,1)\n        len--\n        j--\n      }\n    }\n  }\n  return arr\n}\nconsole.log(unique(arr))\n")])])]),a("h3",{attrs:{id:"_2-filter-indexof去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-filter-indexof去重"}},[t._v("#")]),t._v(" 2. filter+indexOf去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Array.prototype.unique = function(){\n  return this.filter((item, index) => {\n    return this.indexOf(item) === index\n  })\n}\n")])])]),a("h3",{attrs:{id:"_3-foreach-includes去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-foreach-includes去重"}},[t._v("#")]),t._v(" 3. forEach+includes去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Array.prototype.unique = function () {\n  const newArray = [];\n  this.forEach(item => {\n    if (!newArray.includes(item)) {\n      newArray.push(item);\n    }\n  });\n  return newArray;\n}\n")])])]),a("h3",{attrs:{id:"_4-reduce-sort去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-reduce-sort去重"}},[t._v("#")]),t._v(" 4. reduce+sort去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Array.prototype.unique = function(arr){\n  return this.sort().reduce((init, cur) => {\n    if(init.length === 0 || init[init.length-1] !== cur){\n      init.push(cur)\n    } \n    return init \n  }, [])\n}\n")])])]),a("h3",{attrs:{id:"_5-对象键值对去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-对象键值对去重"}},[t._v("#")]),t._v(" 5. 对象键值对去重")]),t._v(" "),a("ul",[a("li",[t._v("利用了对象的key不可以重复的特性来进行去重")]),t._v(" "),a("li",[t._v("但需要注意：\n"),a("ul",[a("li",[t._v("无法区分隐式类型转换成字符串后一样的值，比如 1 和 '1'")]),t._v(" "),a("li",[t._v("无法处理复杂数据类型，比如对象（因为对象作为 key 会变成 [object Object]）")]),t._v(" "),a("li",[t._v("特殊数据，比如 'proto'，因为对象的 proto 属性无法被重写")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Person(){\n  this.a = 1\n}\nconst p = new Person()\nlet arr2 = [1,'1',true,{a: 1},p, 2,3,2,4,4]\nfunction unique(arr){\n  let ret = []\n  let obj = {}\n  for(let item of arr){\n    let tmp\n    if(typeof item === 'object'){\n      let constructor = Object.getPrototypeOf(item).constructor\n      tmp = JSON.stringify(item) + constructor\n    }else{\n      tmp = typeof item + JSON.stringify(item)\n    }\n    if(!obj[tmp]){\n      obj[tmp] = 1\n      ret.push(item)\n    }\n  }\n  return ret\n}\nconsole.log(unique(arr2), arr2)\n")])])]),a("h3",{attrs:{id:"_6-filter-map去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-filter-map去重"}},[t._v("#")]),t._v(" 6. filter+Map去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function unique(arr){\n  let map = new Map()\n  return arr.filter(item => {\n    // if(!map.has(item)){\n    //   map.set(item,1)\n    //   return item\n    // }\n    return !map.has(item) && map.set(item,1)\n  })\n}\n")])])]),a("h3",{attrs:{id:"_7-set去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-set去重"}},[t._v("#")]),t._v(" 7. Set去重")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function unique(arr){\n  let set = new Set(arr)\n  return Array.from(set)\n  // return [...set]\n}\n")])])]),a("h2",{attrs:{id:"三-将类数组对象转为数组-4种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-将类数组对象转为数组-4种"}},[t._v("#")]),t._v(" 三.将类数组对象转为数组(4种)")]),t._v(" "),a("ul",[a("li",[t._v("如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）")]),t._v(" "),a("li",[t._v("典型的“类似数组的对象”：\n"),a("ul",[a("li",[t._v("函数的arguments对象，")]),t._v(" "),a("li",[t._v("以及大多数 DOM 元素集，")]),t._v(" "),a("li",[t._v("还有字符串")])])])]),t._v(" "),a("h3",{attrs:{id:"将类数组转化为真正的数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将类数组转化为真正的数组"}},[t._v("#")]),t._v(" 将类数组转化为真正的数组")]),t._v(" "),a("ul",[a("li",[t._v("es6新增的扩展运算符（...）")]),t._v(" "),a("li",[t._v("es6的Array.from()方法")]),t._v(" "),a("li",[t._v("es6的for...of+push")]),t._v(" "),a("li",[t._v("es5的slice")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let divEle = document.querySelectorAll('div')\nlet divArr = [];\nfor(let item of divEle) {\n    divArr.push(item)\n}\n\nlet divArr = [...divEle];\n\nlet divArr2 = Array.from(divEle)\n\nvar divArr2 = Array.prototype.slice.call(divEle);\n\nlet divArr = [].concat.apply([], divEle) //concat不仅会将类数组对象转为数组，还会将数组展开\n\n")])])]),a("h2",{attrs:{id:"四-洗牌算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-洗牌算法"}},[t._v("#")]),t._v(" 四.洗牌算法")]),t._v(" "),a("ul",[a("li",[t._v("它要求数组中的数打乱后，每个数出现在任意位置的概率相同")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function shuffle(arr){\n  for(let i=0,len=arr.length;i<len;i++){ //缓存一下数组长度\n    const j =  Math.floor(Math.random()*(len-i))\n    //返回一个0到len-i之间的随机整数[0,len-i-1]\n    let tmp = arr[j]\n    arr[j] = arr[len-i-1]\n    arr[len-i-1] = tmp\n  }\n  return arr\n}\nvar arr = [1, 3, 5, 7, 9]\nshuffle(arr)\n")])])]),a("ul",[a("li",[t._v("错误解法：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function shuffle(arr){\n  return arr.sort(()=> Math.random()-0.5)\n}\n// 两数交换的概率为50%，\n//这是为什么呢？问题就出在sort这个API上，对于chrome浏览器而言\n//当数组长度在10以内时，sort()采用插入排序，反之，则混合使用快速排序和插入排序，\n//这样会导致选取的两个交换位置的数不随机，导致数组也就没有真正打乱\n")])])]),a("h2",{attrs:{id:"五-随机数获取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五-随机数获取"}},[t._v("#")]),t._v(" 五.随机数获取")]),t._v(" "),a("ul",[a("li",[t._v("获取一个[0,1)之间的随机数")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Math.random()\n")])])]),a("ul",[a("li",[t._v("获取一个两数之间的随机数[min, max)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Math.random()*(max-min)+min\n")])])]),a("ul",[a("li",[t._v("获取一个两数之间的随机整数[min, max)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function getRandomInt(min, max){\n  min=Math.ceil(min);\n  max=Math.floor(max);\n  return Math.floor(Math.random()*(max-min))+min;\n}\n")])])]),a("ul",[a("li",[t._v("获取一个两数之间的随机整数,包括两个数在内[min, max]")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function getRandomInt(min, max){\n  min=Math.ceil(min)\n  max=Math.floor(max);\n  return Math.floor(Math.random()*(max-min+1))+min;//含最大值，含最小值\n}\n")])])])])}),[],!1,null,null,null);r.default=n.exports}}]);