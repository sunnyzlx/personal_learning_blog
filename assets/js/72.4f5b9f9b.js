(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{430:function(v,e,_){"use strict";_.r(e);var l=_(44),t=Object(l.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" vue")]),v._v(" "),_("h2",{attrs:{id:"vue基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue基础"}},[v._v("#")]),v._v(" vue基础")]),v._v(" "),_("ul",[_("li",[v._v("el, 限制了vue接管DOM的一个范围")]),v._v(" "),_("li",[v._v("前端组件化, 提高复用和后期的可维护性，每个组件其实就是页面上的一个区域")]),v._v(" "),_("li",[v._v("vue生命周期函数, 就是vue实例在某一个时间点会自动执行的函数\n"),_("ul",[_("li",[v._v("初始化vue实例时，首先会初始化事件和生命周期，做一个基础的初始化，之后会调用beforeCreate,\n之后会处理一些外部的注入和数据绑定，这一步vue实例初始化完成，会调用created, 之后会询问vue实例是否有el选项，即挂载点")])])]),v._v(" "),_("li",[v._v("组件, 全局组件, 局部组件")]),v._v(" "),_("li",[v._v("vm, 指vue实例对象")]),v._v(" "),_("li",[v._v("以$开头的属性，是vue的实例属性")]),v._v(" "),_("li",[v._v("计算属性与方法\n"),_("ul",[_("li",[v._v("计算属性会基于他们的依赖进行缓存，只有依赖发生改变，他们才会重新求值")]),v._v(" "),_("li",[v._v("而方法在每次触发重新渲染时，都会重新求值")]),v._v(" "),_("li",[v._v("如果没有缓存，我们将不可避免的多次执行计算属性的getter,而这个计算属性性能开销又比较大，那我们将会浪费很多性能")]),v._v(" "),_("li",[v._v("计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。")])])]),v._v(" "),_("li",[v._v("vue侦听器\n"),_("ul",[_("li",[v._v("vue 通过watch选项，来响应数据的变化")]),v._v(" "),_("li",[v._v("使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的")])])])]),v._v(" "),_("h2",{attrs:{id:"vue最佳实践"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue最佳实践"}},[v._v("#")]),v._v(" vue最佳实践")]),v._v(" "),_("h3",{attrs:{id:"如何利用vue-webpack提升代码效率-精简化-高效化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何利用vue-webpack提升代码效率-精简化-高效化"}},[v._v("#")]),v._v(" 如何利用vue+webpack提升代码效率---精简化，高效化")]),v._v(" "),_("ul",[_("li",[v._v("化繁为简的watch, 字面量名称")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("immediate: true, //创建组件时，立马执行一次\n\nvalue: {\n      handler: 'doSomething',\n      immediate: true\n    }\n")])])]),_("ul",[_("li",[v._v("render函数的妙用\n"),_("ul",[_("li",[v._v("vue推荐在绝大多数情况下使用template创建html，但有一些场景我们需要js完全编程的能力，这就是render函数，它比template更接近编译器")]),v._v(" "),_("li",[v._v("render函数的优点：\n"),_("ul",[_("li",[v._v("ta更接近编译器")]),v._v(" "),_("li",[v._v("使代码精简")]),v._v(" "),_("li",[v._v("可以渲染标签，并添加进虚拟DOM中")])])])])]),v._v(" "),_("li",[v._v("全局组件引入\n"),_("ul",[_("li",[v._v("webpack的require.context() 批量引入")]),v._v(" "),_("li",[v._v("建立一个common文件夹，存放所有需要全局引入的组件")])])]),v._v(" "),_("li",[v._v("总路由动态引入，并实现懒加载，做路由分区，方便业务管理\n"),_("ul",[_("li",[v._v("把不同的业务分成不同的块，然后在总路由中进行引入")])])])]),v._v(" "),_("h2",{attrs:{id:"vue自定义插件库及npm集成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue自定义插件库及npm集成"}},[v._v("#")]),v._v(" vue自定义插件库及npm集成")]),v._v(" "),_("ul",[_("li",[v._v("vue插件封装\n"),_("ul",[_("li",[v._v("插件与组件的关系\n"),_("ul",[_("li",[v._v("组件是对某功能或某模块的封装，如alert，loading")]),v._v(" "),_("li",[v._v("插件是对一系列组件的封装，如vuex, vue-loader")]),v._v(" "),_("li",[v._v("关系：插件可以封装组件，组件可以暴露数据给插件")])])]),v._v(" "),_("li",[v._v("插件的优点\n"),_("ul",[_("li",[v._v("开箱即用")]),v._v(" "),_("li",[v._v("功能比组件更强大，更丰富")]),v._v(" "),_("li",[v._v("可全局引入，使用方便")]),v._v(" "),_("li",[v._v("可以打包，脱离项目存在")])])]),v._v(" "),_("li",[v._v("vue插件分类\n"),_("ul",[_("li",[v._v("install， vue实例， mixin, directive")]),v._v(" "),_("li",[v._v("可以添加全局方法或属性，如vue-element")]),v._v(" "),_("li",[v._v("可以添加全局资源：指令/过滤器/过渡等，如vue-touch")]),v._v(" "),_("li",[v._v("通过全局minin方法添加一些组件选项，如vuex")]),v._v(" "),_("li",[v._v("添加vue实例方法，通过把它们添加到Vue.prototype上实现")])])])])]),v._v(" "),_("li",[v._v("集成到npm")]),v._v(" "),_("li",[v._v("插件优化")])]),v._v(" "),_("h2",{attrs:{id:"vue响应式原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式原理"}},[v._v("#")]),v._v(" vue响应式原理")]),v._v(" "),_("ul",[_("li")])])}),[],!1,null,null,null);e.default=t.exports}}]);